From 03ff362d06ee626f7062ce25cf8bc8bc7c45cc08 Mon Sep 17 00:00:00 2001
From: yangyi <yyanglike@sina.com>
Date: Tue, 23 Dec 2025 10:36:26 +0800
Subject: [PATCH] feat: merge tests into single gtest and add argument
 unpack/kwargs support

- Consolidate test_* into test_attribute_assignment.cpp and add additional cases
- Implement runtime semantics for keyword args, *args/**kwargs, inline assignment-form args, dict merging, and right-associative power
- Add AstVisitor implementations and python_bridge fixes; introduce global Python test env
- Disable/stub duplicate mains in legacy tests
---
 include/ast_visitor.h           |  211 +++
 include/dynamic_python_caller.h |    5 +
 include/error_handler.h         |  192 +++
 include/expression_evaluator.h  |  140 ++
 include/logger.h                |   50 +
 include/script_interpreter.h    |  176 +-
 include/script_value.h          |    3 +
 include/stock_data_processor.h  |    4 +
 include/variable_manager.h      |  151 ++
 python/complex_test_script.py   |   15 +
 src/ast_visitor.cpp             | 2677 +++++++++++++++++++++++++++++++
 src/dynamic_python_caller.cpp   |   21 +-
 src/python_bridge.cpp           |  245 +++
 src/script_interpreter.cpp      | 1791 +++------------------
 src/script_value.cpp            |   22 +
 src/variable_manager.cpp        |  109 ++
 test_attribute_assignment.cpp   |  625 ++++++++
 test_class_handling.cpp         |   56 +-
 test_complex_scenario.cpp       |    5 +
 test_complex_syntax.cpp         |   11 +-
 test_dynamic_call.cpp           |    4 +
 test_enhanced_features.cpp      |  305 ++++
 test_module_enum.cpp            |    4 +
 test_script_interpreter.cpp     |   11 +-
 test_simple.cpp                 |    5 +
 test_simple_if.cpp              |    4 +
 test_subscript_assignment.cpp   |    5 +
 27 files changed, 5116 insertions(+), 1731 deletions(-)
 create mode 100644 include/ast_visitor.h
 create mode 100644 include/error_handler.h
 create mode 100644 include/expression_evaluator.h
 create mode 100644 include/logger.h
 create mode 100644 include/variable_manager.h
 create mode 100644 src/ast_visitor.cpp
 create mode 100644 src/python_bridge.cpp
 create mode 100644 src/variable_manager.cpp
 create mode 100644 test_attribute_assignment.cpp
 create mode 100644 test_enhanced_features.cpp

diff --git a/include/ast_visitor.h b/include/ast_visitor.h
new file mode 100644
index 0000000..fcbd8df
--- /dev/null
+++ b/include/ast_visitor.h
@@ -0,0 +1,211 @@
+/**
+ * @file ast_visitor.h
+ * @brief ANTLR语法树访问者模块
+ * 
+ * 该模块负责遍历ANTLR生成的抽象语法树（AST），执行相应的语义动作。
+ * 将所有的visitor方法从ScriptInterpreter中分离出来，专注于语法树的遍历和解析。
+ */
+
+#pragma once
+
+#include <string>
+#include <memory>
+#include <vector>
+#include <any>
+#include <pybind11/pybind11.h>
+#include "script_value.h"
+#include "variable_manager.h"
+#include "error_handler.h"
+#include "logger.h"
+#include "python_bridge.h"
+#include "expression_evaluator.h"
+#include "antlr/PyScriptVisitor.h"
+
+namespace py = pybind11;
+
+namespace antlr4 {
+class ParserRuleContext;
+}
+
+namespace script_interpreter {
+
+/**
+ * @class AstVisitor
+ * @brief 抽象语法树访问者类
+ * 
+ * 实现ANTLR的PyScriptVisitor接口，负责遍历语法树并执行相应的语义动作。
+ * 与ScriptInterpreter解耦，专注于语法树的解析和转换。
+ */
+class AstVisitor : public PyScriptVisitor {
+public:
+    /**
+     * @brief 构造函数
+     * @param variable_manager 变量管理器引用
+     * @param error_handler 错误处理器引用
+     * @param logger 日志记录器引用
+     * @param python_bridge Python桥接器引用
+     * @param expression_evaluator 表达式求值引擎引用
+     */
+    AstVisitor(VariableManager& variable_manager,
+               ErrorHandler& error_handler,
+               Logger& logger,
+               PythonBridge& python_bridge,
+               ExpressionEvaluator& expression_evaluator);
+    
+    /**
+     * @brief 析构函数
+     */
+    virtual ~AstVisitor() = default;
+    
+    // Visitor接口实现
+    std::any visitProgram(PyScriptParser::ProgramContext *ctx) override;
+    std::any visitStatement(PyScriptParser::StatementContext *ctx) override;
+    std::any visitImportStatement(PyScriptParser::ImportStatementContext *ctx) override;
+    std::any visitFunctionDefinition(PyScriptParser::FunctionDefinitionContext *ctx) override;
+    std::any visitParameterList(PyScriptParser::ParameterListContext *ctx) override;
+    std::any visitIfStatement(PyScriptParser::IfStatementContext *ctx) override;
+    std::any visitWhileStatement(PyScriptParser::WhileStatementContext *ctx) override;
+    std::any visitReturnStatement(PyScriptParser::ReturnStatementContext *ctx) override;
+    std::any visitBlock(PyScriptParser::BlockContext *ctx) override;
+    std::any visitAssignment(PyScriptParser::AssignmentContext *ctx) override;
+    std::any visitAssignmentOperator(PyScriptParser::AssignmentOperatorContext *ctx) override;
+    std::any visitExpressionStatement(PyScriptParser::ExpressionStatementContext *ctx) override;
+    std::any visitExpression(PyScriptParser::ExpressionContext *ctx) override;
+    std::any visitTernaryExpression(PyScriptParser::TernaryExpressionContext *ctx) override;
+    std::any visitLogicalOrExpression(PyScriptParser::LogicalOrExpressionContext *ctx) override;
+    std::any visitLogicalAndExpression(PyScriptParser::LogicalAndExpressionContext *ctx) override;
+    std::any visitEqualityExpression(PyScriptParser::EqualityExpressionContext *ctx) override;
+    std::any visitRelationalExpression(PyScriptParser::RelationalExpressionContext *ctx) override;
+    std::any visitAdditiveExpression(PyScriptParser::AdditiveExpressionContext *ctx) override;
+    std::any visitMultiplicativeExpression(PyScriptParser::MultiplicativeExpressionContext *ctx) override;
+    std::any visitUnaryExpression(PyScriptParser::UnaryExpressionContext *ctx) override;
+    std::any visitCallOrPrimary(PyScriptParser::CallOrPrimaryContext *ctx) override;
+    std::any visitFunctionCall(PyScriptParser::FunctionCallContext *ctx) override;
+    std::any visitAttributeAccess(PyScriptParser::AttributeAccessContext *ctx) override;
+    std::any visitSubscriptAccess(PyScriptParser::SubscriptAccessContext *ctx) override;
+    std::any visitPrimaryExpression(PyScriptParser::PrimaryExpressionContext *ctx) override;
+    std::any visitNewExpression(PyScriptParser::NewExpressionContext *ctx) override;
+    std::any visitLiteral(PyScriptParser::LiteralContext *ctx) override;
+    std::any visitListLiteral(PyScriptParser::ListLiteralContext *ctx) override;
+    std::any visitDictLiteral(PyScriptParser::DictLiteralContext *ctx) override;
+    std::any visitDottedName(PyScriptParser::DottedNameContext *ctx) override;
+    std::any visitArgumentList(PyScriptParser::ArgumentListContext *ctx) override;
+    std::any visitArgument(PyScriptParser::ArgumentContext *ctx) override;
+    std::any visitParameter(PyScriptParser::ParameterContext *ctx) override;
+    std::any visitPowerExpression(PyScriptParser::PowerExpressionContext *ctx) override;
+    std::any visitExpressionList(PyScriptParser::ExpressionListContext *ctx) override; 
+    std::any visitDictItemList(PyScriptParser::DictItemListContext *ctx) override;
+    std::any visitKeyValuePair(PyScriptParser::KeyValuePairContext *ctx) override;
+    std::any visitDictUnpack(PyScriptParser::DictUnpackContext *ctx) override;
+    std::any visitLambdaExpression(PyScriptParser::LambdaExpressionContext *ctx) override;
+    std::any visitForStatement(PyScriptParser::ForStatementContext *ctx) override;
+    std::any visitForControl(PyScriptParser::ForControlContext *ctx) override;
+    std::any visitForInit(PyScriptParser::ForInitContext *ctx) override;
+    std::any visitForUpdate(PyScriptParser::ForUpdateContext *ctx) override;
+    std::any visitListComprehension(PyScriptParser::ListComprehensionContext *ctx) override;
+    std::any visitAttributeAccessOp(PyScriptParser::AttributeAccessOpContext *ctx) override;
+    std::any visitSubscriptAccessOp(PyScriptParser::SubscriptAccessOpContext *ctx) override;
+    std::any visitFunctionCallOp(PyScriptParser::FunctionCallOpContext *ctx) override;
+    
+    /**
+     * @brief 设置定义函数标志
+     * @param defining 是否正在定义函数
+     */
+    void setDefiningFunction(bool defining) { defining_function_ = defining; }
+    
+    /**
+     * @brief 获取定义函数标志
+     * @return 是否正在定义函数
+     */
+    bool isDefiningFunction() const { return defining_function_; }
+    
+    /**
+     * @brief 设置执行结果
+     * @param result 执行结果
+     */
+    void setResult(std::shared_ptr<ScriptValue> result) { result_ = result; }
+    
+    /**
+     * @brief 获取执行结果
+     * @return 执行结果
+     */
+    std::shared_ptr<ScriptValue> getResult() const { return result_; }
+    
+    /**
+     * @brief 求值表达式
+     * @param ctx 表达式上下文
+     * @return 表达式求值结果
+     */
+    std::shared_ptr<ScriptValue> evaluateExpression(PyScriptParser::ExpressionContext *ctx);
+    
+    /**
+     * @brief 报告错误
+     * @param message 错误消息
+     * @param type 错误类型（默认Runtime）
+     * @param code 错误代码（默认Unknown）
+     * @param line 行号（默认-1）
+     * @param column 列号（默认-1）
+     */
+    void reportError(const std::string& message,
+                    ScriptErrorType type = ScriptErrorType::Runtime,
+                    ScriptErrorCode code = ScriptErrorCode::Unknown,
+                    int line = -1, int column = -1);
+    
+    /**
+     * @brief 报告错误（带上下文）
+     * @param message 错误消息
+     * @param ctx 解析器规则上下文
+     * @param type 错误类型（默认Runtime）
+     * @param code 错误代码（默认Unknown）
+     */
+    void reportError(const std::string& message, antlr4::ParserRuleContext *ctx,
+                    ScriptErrorType type = ScriptErrorType::Runtime,
+                    ScriptErrorCode code = ScriptErrorCode::Unknown);
+    
+    /**
+     * @brief 获取变量
+     * @param name 变量名
+     * @return 变量值
+     */
+    std::shared_ptr<ScriptValue> getVariable(const std::string& name);
+    
+    /**
+     * @brief 设置变量
+     * @param name 变量名
+     * @param value 变量值
+     */
+    void setVariable(const std::string& name, std::shared_ptr<ScriptValue> value);
+    
+    /**
+     * @brief 执行代码块
+     * @param ctx 代码块上下文
+     * @return 代码块执行结果
+     */
+    std::shared_ptr<ScriptValue> executeBlock(PyScriptParser::BlockContext *ctx);
+    
+private:
+    // 模块引用
+    VariableManager& variable_manager_;
+    ErrorHandler& error_handler_;
+    Logger& logger_;
+    PythonBridge& python_bridge_;
+    ExpressionEvaluator& expression_evaluator_;
+    
+    // 执行状态
+    std::shared_ptr<ScriptValue> result_; ///< 执行结果
+    bool defining_function_;               ///< 是否正在定义函数
+    
+    /**
+     * @brief 获取Python桥接器
+     * @return Python桥接器引用
+     */
+    PythonBridge& getPythonBridge() { return python_bridge_; }
+    
+    /**
+     * @brief 获取表达式求值引擎
+     * @return 表达式求值引擎引用
+     */
+    ExpressionEvaluator& getExpressionEvaluator() { return expression_evaluator_; }
+};
+
+} // namespace script_interpreter
diff --git a/include/dynamic_python_caller.h b/include/dynamic_python_caller.h
index 3beac41..6fb5ec9 100644
--- a/include/dynamic_python_caller.h
+++ b/include/dynamic_python_caller.h
@@ -3,6 +3,7 @@
 
 #include <pybind11/embed.h>
 #include <pybind11/stl.h>
+#include "logger.h"
 #include <string>
 #include <vector>
 #include <map>
@@ -162,6 +163,10 @@ private:
     static std::vector<std::string> getClassMembers(py::object classObj, 
                                                     const std::string& memberType,
                                                     bool includeInherited);
+
+private:
+    // logger
+    Logger logger_;
 };
 
 #endif // DYNAMIC_PYTHON_CALLER_H
diff --git a/include/error_handler.h b/include/error_handler.h
new file mode 100644
index 0000000..c38e4af
--- /dev/null
+++ b/include/error_handler.h
@@ -0,0 +1,192 @@
+/**
+ * @file error_handler.h
+ * @brief 错误处理模块，负责统一的错误报告和处理
+ * 
+ * 该模块提供了一套完整的错误处理机制，包括错误类型定义、
+ * 错误信息收集、错误报告和日志记录等功能。
+ */
+
+#pragma once
+
+#include <string>
+#include <memory>
+#include <vector>
+#include <optional>
+
+namespace script_interpreter {
+
+/**
+ * @enum ScriptErrorType
+ * @brief 脚本错误类型
+ */
+enum class ScriptErrorType {
+    Syntax,     ///< 语法错误
+    Semantic,   ///< 语义错误
+    Runtime,    ///< 运行时错误
+    Python,     ///< Python相关错误
+    System      ///< 系统错误
+};
+
+/**
+ * @enum ScriptErrorCode
+ * @brief 脚本错误代码
+ */
+enum class ScriptErrorCode {
+    Unknown,                ///< 未知错误
+    InvalidSyntax,          ///< 无效语法
+    UndefinedIdentifier,    ///< 未定义标识符
+    TypeMismatch,           ///< 类型不匹配
+    DivisionByZero,         ///< 除以零
+    OutOfBounds,            ///< 下标越界
+    PythonException,        ///< Python异常
+    UnsupportedOperation,   ///< 不支持的操作
+    FileNotFound,           ///< 文件未找到
+    ImportError,            ///< 导入错误
+    MaxErrorCode            ///< 最大错误代码（用于边界检查）
+};
+
+/**
+ * @class ScriptError
+ * @brief 脚本错误信息类
+ * 
+ * 封装了错误的详细信息，包括错误类型、错误代码、错误消息、
+ * 发生位置（行号和列号）等。
+ */
+class ScriptError {
+public:
+    /**
+     * @brief 构造函数
+     * @param type 错误类型
+     * @param code 错误代码
+     * @param message 错误消息
+     * @param line 行号（默认-1表示未知）
+     * @param column 列号（默认-1表示未知）
+     */
+    ScriptError(ScriptErrorType type, 
+                ScriptErrorCode code, 
+                const std::string& message,
+                int line = -1,
+                int column = -1);
+    
+    /**
+     * @brief 获取错误类型
+     * @return 错误类型
+     */
+    ScriptErrorType getType() const { return type_; }
+    
+    /**
+     * @brief 获取错误代码
+     * @return 错误代码
+     */
+    ScriptErrorCode getCode() const { return code_; }
+    
+    /**
+     * @brief 获取错误消息
+     * @return 错误消息
+     */
+    const std::string& getMessage() const { return message_; }
+    
+    /**
+     * @brief 获取行号
+     * @return 行号，-1表示未知
+     */
+    int getLine() const { return line_; }
+    
+    /**
+     * @brief 获取列号
+     * @return 列号，-1表示未知
+     */
+    int getColumn() const { return column_; }
+    
+    /**
+     * @brief 获取完整的错误信息字符串
+     * @return 格式化的错误信息
+     */
+    std::string toString() const;
+    
+    /**
+     * @brief 检查是否发生在特定位置
+     * @return 如果有位置信息返回true，否则false
+     */
+    bool hasLocation() const { return line_ >= 0 && column_ >= 0; }
+    
+private:
+    ScriptErrorType type_;      ///< 错误类型
+    ScriptErrorCode code_;      ///< 错误代码
+    std::string message_;       ///< 错误消息
+    int line_;                  ///< 行号
+    int column_;                ///< 列号
+};
+
+/**
+ * @class ErrorHandler
+ * @brief 错误处理器类
+ * 
+ * 负责收集、管理和报告错误信息，提供错误状态查询和错误信息
+ * 获取功能。支持链式错误报告。
+ */
+class ErrorHandler {
+public:
+    ErrorHandler();
+    
+    /**
+     * @brief 报告错误
+     * @param error 错误对象
+     */
+    void reportError(const ScriptError& error);
+    
+    /**
+     * @brief 报告错误（便捷方法）
+     * @param message 错误消息
+     * @param type 错误类型（默认Runtime）
+     * @param code 错误代码（默认Unknown）
+     * @param line 行号（默认-1）
+     * @param column 列号（默认-1）
+     */
+    void reportError(const std::string& message,
+                    ScriptErrorType type = ScriptErrorType::Runtime,
+                    ScriptErrorCode code = ScriptErrorCode::Unknown,
+                    int line = -1,
+                    int column = -1);
+    
+    /**
+     * @brief 检查是否有错误发生
+     * @return 如果有错误返回true，否则false
+     */
+    bool hasError() const { return has_error_; }
+    
+    /**
+     * @brief 获取最后一个错误
+     * @return 最后一个错误对象，如果没有错误返回std::nullopt
+     */
+    std::optional<ScriptError> getLastError() const;
+    
+    /**
+     * @brief 获取错误消息
+     * @return 最后一个错误的错误消息，如果没有错误返回空字符串
+     */
+    std::string getErrorMessage() const;
+    
+    /**
+     * @brief 获取所有错误
+     * @return 所有错误对象的向量
+     */
+    std::vector<ScriptError> getAllErrors() const { return errors_; }
+    
+    /**
+     * @brief 清除所有错误
+     */
+    void clearErrors();
+    
+    /**
+     * @brief 获取错误数量
+     * @return 错误数量
+     */
+    size_t getErrorCount() const { return errors_.size(); }
+    
+private:
+    bool has_error_;                    ///< 是否有错误发生
+    std::vector<ScriptError> errors_;   ///< 错误列表
+};
+
+} // namespace script_interpreter
diff --git a/include/expression_evaluator.h b/include/expression_evaluator.h
new file mode 100644
index 0000000..5d0d8be
--- /dev/null
+++ b/include/expression_evaluator.h
@@ -0,0 +1,140 @@
+/**
+ * @file expression_evaluator.h
+ * @brief 表达式求值引擎模块
+ * 
+ * 该模块负责所有表达式的求值操作，包括：
+ * - 二元运算（加减乘除、比较、逻辑运算等）
+ * - 一元运算（负号、逻辑非等）
+ * - 真值判断
+ * - 表达式求值
+ * - 代码块执行
+ */
+
+#pragma once
+
+#include <string>
+#include <memory>
+#include <vector>
+#include <any>
+#include <pybind11/pybind11.h>
+#include "script_value.h"
+#include "variable_manager.h"
+#include "error_handler.h"
+#include "logger.h"
+#include "python_bridge.h"
+#include "antlr/PyScriptParser.h"
+
+namespace py = pybind11;
+
+namespace antlr4 {
+namespace tree {
+class ParseTree;
+}
+}
+
+namespace script_interpreter {
+
+/**
+ * @class ExpressionEvaluator
+ * @brief 表达式求值引擎类
+ * 
+ * 封装所有表达式求值相关的逻辑，提供独立的表达式求值服务。
+ * 与具体的语法解析器解耦，专注于表达式的计算。
+ */
+class ExpressionEvaluator {
+public:
+    /**
+     * @brief 构造函数
+     * @param variable_manager 变量管理器引用
+     * @param error_handler 错误处理器引用
+     * @param logger 日志记录器引用
+     * @param python_bridge Python桥接器引用
+     */
+    ExpressionEvaluator(VariableManager& variable_manager,
+                       ErrorHandler& error_handler,
+                       Logger& logger,
+                       PythonBridge& python_bridge);
+    
+    /**
+     * @brief 求值二元运算
+     * @param op 操作符字符串
+     * @param left 左操作数
+     * @param right 右操作数
+     * @return 运算结果，如果出错返回nullptr
+     */
+    std::shared_ptr<ScriptValue> evaluateBinaryOperation(
+        const std::string& op,
+        std::shared_ptr<ScriptValue> left,
+        std::shared_ptr<ScriptValue> right);
+    
+    /**
+     * @brief 求值一元运算
+     * @param op 操作符字符串
+     * @param value 操作数
+     * @return 运算结果，如果出错返回nullptr
+     */
+    std::shared_ptr<ScriptValue> evaluateUnaryOperation(
+        const std::string& op,
+        std::shared_ptr<ScriptValue> value);
+    
+    /**
+     * @brief 判断值的真值性
+     * @param value 要判断的值
+     * @return 如果值为真返回true，否则false
+     */
+    bool isTruthy(std::shared_ptr<ScriptValue> value) const;
+    
+    /**
+     * @brief 求值表达式上下文
+     * @param ctx 表达式上下文
+     * @return 表达式求值结果，封装为any
+     */
+    std::any evaluateExpression(PyScriptParser::ExpressionContext* ctx);
+    
+    /**
+     * @brief 执行代码块
+     * @param ctx 代码块上下文
+     * @return 代码块中最后一条语句的值
+     */
+    std::shared_ptr<ScriptValue> executeBlock(PyScriptParser::BlockContext* ctx);
+    
+    /**
+     * @brief 获取变量管理器引用
+     * @return 变量管理器引用
+     */
+    VariableManager& getVariableManager() { return variable_manager_; }
+    
+    /**
+     * @brief 获取错误处理器引用
+     * @return 错误处理器引用
+     */
+    ErrorHandler& getErrorHandler() { return error_handler_; }
+    
+    /**
+     * @brief 获取日志记录器引用
+     * @return 日志记录器引用
+     */
+    Logger& getLogger() { return logger_; }
+    
+    /**
+     * @brief 获取Python桥接器引用
+     * @return Python桥接器引用
+     */
+    PythonBridge& getPythonBridge() { return python_bridge_; }
+    
+private:
+    VariableManager& variable_manager_;
+    ErrorHandler& error_handler_;
+    Logger& logger_;
+    PythonBridge& python_bridge_;
+    
+    /**
+     * @brief 报告错误
+     * @param message 错误消息
+     * @param line 行号（可选）
+     * @param column 列号（可选）
+     */
+    void reportError(const std::string& message, int line = -1, int column = -1);
+};
+
+} // namespace script_interpreter
diff --git a/include/logger.h b/include/logger.h
new file mode 100644
index 0000000..b343df2
--- /dev/null
+++ b/include/logger.h
@@ -0,0 +1,50 @@
+#pragma once
+
+#include <iostream>
+#include <sstream>
+#include <string>
+#include <mutex>
+
+enum class LogLevel {
+    Debug = 0,
+    Info,
+    Warn,
+    Error,
+    Off
+};
+
+class Logger {
+public:
+    Logger() : level_(LogLevel::Info), out_(&std::cerr) {}
+
+    void setLevel(LogLevel level) { level_ = level; }
+    LogLevel getLevel() const { return level_; }
+
+    void setOutput(std::ostream& os) { std::lock_guard<std::mutex> lk(mu_); out_ = &os; }
+
+    void log(LogLevel lvl, const std::string& message) {
+        if (lvl < level_ || level_ == LogLevel::Off) return;
+        std::lock_guard<std::mutex> lk(mu_);
+        (*out_) << '[' << levelToString(lvl) << "] " << message << std::endl;
+    }
+
+    void debug(const std::string& msg) { log(LogLevel::Debug, msg); }
+    void info(const std::string& msg) { log(LogLevel::Info, msg); }
+    void warn(const std::string& msg) { log(LogLevel::Warn, msg); }
+    void error(const std::string& msg) { log(LogLevel::Error, msg); }
+
+private:
+    const char* levelToString(LogLevel lvl) const {
+        switch (lvl) {
+            case LogLevel::Debug: return "DEBUG";
+            case LogLevel::Info: return "INFO";
+            case LogLevel::Warn: return "WARN";
+            case LogLevel::Error: return "ERROR";
+            default: return "UNKNOWN";
+        }
+    }
+
+    LogLevel level_;
+    std::ostream* out_;
+    std::mutex mu_;
+};
diff --git a/include/script_interpreter.h b/include/script_interpreter.h
index 7b04610..88a2469 100644
--- a/include/script_interpreter.h
+++ b/include/script_interpreter.h
@@ -1,17 +1,67 @@
+#include <string>
+#include <optional>
+#include <ostream>
+
+// 错误类型枚举
+enum class ScriptErrorType {
+    Syntax,
+    Runtime,
+    Type,
+    Python,
+    Unknown
+};
+
+// 错误码枚举
+enum class ScriptErrorCode {
+    None,
+    InvalidSyntax,
+    VariableNotDefined,
+    TypeMismatch,
+    PythonException,
+    UnsupportedOperation,
+    FileNotFound,
+    Unknown
+};
+
+// 错误对象
+struct ScriptError {
+    ScriptErrorType type;
+    ScriptErrorCode code;
+    std::string message;
+    int line = -1;
+    int column = -1;
+    ScriptError(ScriptErrorType t, ScriptErrorCode c, const std::string& msg, int l = -1, int col = -1)
+        : type(t), code(c), message(msg), line(l), column(col) {}
+};
 #ifndef SCRIPT_INTERPRETER_H
 #define SCRIPT_INTERPRETER_H
 
-#include "script_value.h"
-#include "antlr/PyScriptVisitor.h"
 #include <string>
 #include <memory>
-#include <unordered_map>
-#include <vector>
+#include <optional>
+#include "script_value.h"
+#include "antlr/PyScriptVisitor.h"
+#include "logger.h"
+#include "error_handler.h"
+#include "variable_manager.h"
+#include "python_bridge.h"
+#include "expression_evaluator.h"
+#include "ast_visitor.h"
 #include <pybind11/pybind11.h>
 #include <pybind11/embed.h>
 
 namespace py = pybind11;
 
+namespace script_interpreter {
+
+/**
+ * @class ScriptInterpreter
+ * @brief 脚本解释器主类，负责协调各个模块执行脚本
+ * 
+ * 该类是整个脚本解释系统的核心，负责语法解析、表达式求值、
+ * Python交互等功能的协调。通过模块化设计，将不同职责分离到
+ * 专门的模块中，提高代码的可维护性和可扩展性。
+ */
 class ScriptInterpreter : public PyScriptVisitor {
 public:
     // 构造函数和析构函数
@@ -22,22 +72,24 @@ public:
     bool execute(const std::string& script);
     bool executeFile(const std::string& filename);
     
-    // 获取变量
+    // 变量管理接口
     std::shared_ptr<ScriptValue> getVariable(const std::string& name);
-    
-    // 设置变量
     void setVariable(const std::string& name, std::shared_ptr<ScriptValue> value);
-    
-    // 清空环境
     void clearEnvironment();
     
-    // 获取执行结果
+    // 日志配置
+    void setLogLevel(LogLevel level) { logger_.setLevel(level); }
+    void setLogOutput(std::ostream& os) { logger_.setOutput(os); }
+    
+    // 执行结果获取
     std::shared_ptr<ScriptValue> getResult() const { return result_; }
     
-    // 检查是否有错误
-    bool hasError() const { return has_error_; }
-    const std::string& getErrorMessage() const { return error_message_; }
-
+    // 错误处理接口
+    bool hasError() const { return error_handler_.hasError(); }
+    std::string getErrorMessage() const { return error_handler_.getErrorMessage(); }
+    std::optional<ScriptError> getLastError() const { return error_handler_.getLastError(); }
+    std::vector<ScriptError> getAllErrors() const { return error_handler_.getAllErrors(); }
+    
     // Visitor接口实现
     std::any visitProgram(PyScriptParser::ProgramContext *ctx) override;
     std::any visitStatement(PyScriptParser::StatementContext *ctx) override;
@@ -71,8 +123,11 @@ public:
     std::any visitDictLiteral(PyScriptParser::DictLiteralContext *ctx) override;
     std::any visitDottedName(PyScriptParser::DottedNameContext *ctx) override;
     std::any visitArgumentList(PyScriptParser::ArgumentListContext *ctx) override;
+    std::any visitArgument(PyScriptParser::ArgumentContext *ctx) override;
+    std::any visitParameter(PyScriptParser::ParameterContext *ctx) override;
+    std::any visitPowerExpression(PyScriptParser::PowerExpressionContext *ctx) override;
     std::any visitExpressionList(PyScriptParser::ExpressionListContext *ctx) override;
-    std::any visitDictItemList(PyScriptParser::DictItemListContext *ctx) override;
+    std::any visitDictItemList(PyScriptParser::DictItemListContext *ctx) override; 
     std::any visitKeyValuePair(PyScriptParser::KeyValuePairContext *ctx) override;
     std::any visitDictUnpack(PyScriptParser::DictUnpackContext *ctx) override;
     std::any visitLambdaExpression(PyScriptParser::LambdaExpressionContext *ctx) override;
@@ -88,79 +143,34 @@ public:
     std::any visitFunctionCallOp(PyScriptParser::FunctionCallOpContext *ctx) override;
 
 private:
-    // 变量环境
-    std::unordered_map<std::string, std::shared_ptr<ScriptValue>> variables_;
-    
-    // 导入的Python模块
-    std::unordered_map<std::string, py::module_> imported_modules_;
-    
-    // 执行结果
-    std::shared_ptr<ScriptValue> result_;
-    
-    // 错误状态
-    bool has_error_;
-    std::string error_message_;
+    // 模块化组件
+    Logger logger_;                    ///< 日志记录器
+    ErrorHandler error_handler_;       ///< 错误处理器
+    VariableManager variable_manager_; ///< 变量管理器
+    PythonBridge python_bridge_;       ///< Python桥接器
+    AstVisitor ast_visitor_;           ///< AST访问器
     
-    // Python内置函数
-    py::object builtins_;
-    
-    // 当前是否在Python解释器控制下
-    bool python_initialized_;
-    
-    // 是否正在定义函数（用于避免在函数定义体中报错）
-    bool defining_function_;
+    // 执行状态
+    std::shared_ptr<ScriptValue> result_; ///< 执行结果
+    bool defining_function_;               ///< 是否正在定义函数
     
     // 辅助方法
-    void reportError(const std::string& message);
-    void reportError(const std::string& message, antlr4::ParserRuleContext *ctx);
-    
-    // 表达式求值辅助方法
+    void reportError(const std::string& message,
+                    ScriptErrorType type = ScriptErrorType::Runtime,
+                    ScriptErrorCode code = ScriptErrorCode::Unknown,
+                    int line = -1, int column = -1);
+    void reportError(const std::string& message, antlr4::ParserRuleContext *ctx,
+                    ScriptErrorType type = ScriptErrorType::Runtime,
+                    ScriptErrorCode code = ScriptErrorCode::Unknown);
+    
+    // 表达式求值引擎
+    ExpressionEvaluator expression_evaluator_;
+    
+    // 表达式求值辅助方法（委托给expression_evaluator_）
     std::shared_ptr<ScriptValue> evaluateExpression(PyScriptParser::ExpressionContext *ctx);
-    std::shared_ptr<ScriptValue> evaluateTernary(PyScriptParser::TernaryExpressionContext *ctx);
-    std::shared_ptr<ScriptValue> evaluateLogicalOr(PyScriptParser::LogicalOrExpressionContext *ctx);
-    std::shared_ptr<ScriptValue> evaluateLogicalAnd(PyScriptParser::LogicalAndExpressionContext *ctx);
-    std::shared_ptr<ScriptValue> evaluateEquality(PyScriptParser::EqualityExpressionContext *ctx);
-    std::shared_ptr<ScriptValue> evaluateRelational(PyScriptParser::RelationalExpressionContext *ctx);
-    std::any evaluateAdditive(PyScriptParser::AdditiveExpressionContext *ctx);
-    std::any evaluateMultiplicative(PyScriptParser::MultiplicativeExpressionContext *ctx);
-    std::any evaluateUnary(PyScriptParser::UnaryExpressionContext *ctx);
-    
-    // 运算符求值
-    std::shared_ptr<ScriptValue> evaluateBinaryOperation(
-        const std::string& op,
-        std::shared_ptr<ScriptValue> left,
-        std::shared_ptr<ScriptValue> right);
-    
-    std::shared_ptr<ScriptValue> evaluateUnaryOperation(
-        const std::string& op,
-        std::shared_ptr<ScriptValue> value);
-    
-    // 类型转换
-    bool isTruthy(std::shared_ptr<ScriptValue> value) const;
-    
-    // Python集成
-    std::shared_ptr<ScriptValue> callPythonFunction(
-        py::object func,
-        const std::vector<std::shared_ptr<ScriptValue>>& args);
-    
-    std::shared_ptr<ScriptValue> createPythonInstance(
-        const std::string& moduleName,
-        const std::string& className,
-        const std::vector<std::shared_ptr<ScriptValue>>& args);
-    
-    // 获取成员
-    std::shared_ptr<ScriptValue> getMember(
-        std::shared_ptr<ScriptValue> object,
-        const std::string& memberName);
-    
-    // 设置成员
-    void setMember(
-        std::shared_ptr<ScriptValue> object,
-        const std::string& memberName,
-        std::shared_ptr<ScriptValue> value);
-    
-    // 执行代码块
     std::shared_ptr<ScriptValue> executeBlock(PyScriptParser::BlockContext *ctx);
 };
 
+} // namespace script_interpreter
+
 #endif // SCRIPT_INTERPRETER_H
diff --git a/include/script_value.h b/include/script_value.h
index 182acbf..82b287c 100644
--- a/include/script_value.h
+++ b/include/script_value.h
@@ -96,6 +96,9 @@ public:
     void setList(const std::vector<std::shared_ptr<ScriptValue>>& val);
     void setDictionary(const std::unordered_map<std::string, std::shared_ptr<ScriptValue>>& val);
 
+    // 成员操作（用于对象属性赋值）
+    void setMember(const std::string& name, std::shared_ptr<ScriptValue> val);
+
     // 列表操作
     void append(std::shared_ptr<ScriptValue> val);
     std::shared_ptr<ScriptValue> getAt(size_t index) const;
diff --git a/include/stock_data_processor.h b/include/stock_data_processor.h
index 816a450..d59b438 100644
--- a/include/stock_data_processor.h
+++ b/include/stock_data_processor.h
@@ -11,6 +11,7 @@
 #include <thread>
 #include <pybind11/embed.h>
 #include <pybind11/stl.h>
+#include "logger.h"
 
 namespace py = pybind11;
 
@@ -77,6 +78,9 @@ private:
     std::atomic<bool> isRunning_;
     std::atomic<bool> shouldCancel_;
     std::unique_ptr<std::thread> fetchThread_;
+
+    // logger
+    mutable Logger logger_;
 };
 
 #endif // STOCK_DATA_PROCESSOR_H
diff --git a/include/variable_manager.h b/include/variable_manager.h
new file mode 100644
index 0000000..2527794
--- /dev/null
+++ b/include/variable_manager.h
@@ -0,0 +1,151 @@
+/**
+ * @file variable_manager.h
+ * @brief 变量管理模块，负责变量和模块的存储、查找和管理
+ * 
+ * 该模块提供了变量和模块的存储管理功能，支持变量的增删改查，
+ * 模块的导入和缓存，以及作用域管理（未来扩展）。
+ */
+
+#pragma once
+
+#include <string>
+#include <memory>
+#include <unordered_map>
+#include <optional>
+#include <pybind11/pybind11.h>
+
+namespace py = pybind11;
+
+class ScriptValue;
+
+namespace script_interpreter {
+
+/**
+ * @class VariableManager
+ * @brief 变量管理器类
+ * 
+ * 负责管理脚本执行过程中的变量和导入的Python模块。
+ * 提供变量和模块的存储、查找、更新和删除功能。
+ */
+class VariableManager {
+public:
+    VariableManager();
+    
+    /**
+     * @brief 设置变量
+     * @param name 变量名
+     * @param value 变量值
+     */
+    void setVariable(const std::string& name, std::shared_ptr<ScriptValue> value);
+    
+    /**
+     * @brief 获取变量
+     * @param name 变量名
+     * @return 变量值，如果不存在返回nullptr
+     */
+    std::shared_ptr<ScriptValue> getVariable(const std::string& name) const;
+    
+    /**
+     * @brief 检查变量是否存在
+     * @param name 变量名
+     * @return 如果存在返回true，否则false
+     */
+    bool hasVariable(const std::string& name) const;
+    
+    /**
+     * @brief 删除变量
+     * @param name 变量名
+     * @return 如果成功删除返回true，如果变量不存在返回false
+     */
+    bool removeVariable(const std::string& name);
+    
+    /**
+     * @brief 导入Python模块
+     * @param moduleName 模块名
+     * @param module Python模块对象
+     */
+    void importModule(const std::string& moduleName, py::module_ module);
+    
+    /**
+     * @brief 获取导入的Python模块
+     * @param moduleName 模块名
+     * @return Python模块对象，如果不存在返回空对象
+     */
+    py::module_ getModule(const std::string& moduleName) const;
+    
+    /**
+     * @brief 检查模块是否已导入
+     * @param moduleName 模块名
+     * @return 如果已导入返回true，否则false
+     */
+    bool hasModule(const std::string& moduleName) const;
+    
+    /**
+     * @brief 清空所有变量（保留导入的模块）
+     */
+    void clearVariables();
+    
+    /**
+     * @brief 清空所有模块
+     */
+    void clearModules();
+    
+    /**
+     * @brief 清空所有变量和模块
+     */
+    void clearAll();
+    
+    /**
+     * @brief 获取所有变量名
+     * @return 变量名列表
+     */
+    std::vector<std::string> getAllVariableNames() const;
+    
+    /**
+     * @brief 获取所有模块名
+     * @return 模块名列表
+     */
+    std::vector<std::string> getAllModuleNames() const;
+    
+    /**
+     * @brief 获取变量数量
+     * @return 变量数量
+     */
+    size_t getVariableCount() const;
+    
+    /**
+     * @brief 获取模块数量
+     * @return 模块数量
+     */
+    size_t getModuleCount() const;
+    
+    /**
+     * @brief 设置内置Python模块（如builtins）
+     * @param builtins 内置模块对象
+     */
+    void setBuiltins(py::object builtins);
+    
+    /**
+     * @brief 获取内置Python模块
+     * @return 内置模块对象
+     */
+    py::object getBuiltins() const;
+    
+    /**
+     * @brief 检查是否设置了内置模块
+     * @return 如果已设置返回true，否则false
+     */
+    bool hasBuiltins() const;
+    
+private:
+    // 变量存储
+    std::unordered_map<std::string, std::shared_ptr<ScriptValue>> variables_;
+    
+    // 导入的Python模块存储
+    std::unordered_map<std::string, py::module_> imported_modules_;
+    
+    // 内置Python模块（如builtins）
+    py::object builtins_;
+};
+
+} // namespace script_interpreter
diff --git a/python/complex_test_script.py b/python/complex_test_script.py
index 7979e03..8229c75 100644
--- a/python/complex_test_script.py
+++ b/python/complex_test_script.py
@@ -50,6 +50,21 @@ class ComplexData:
         
         return merged
 
+    # Compatibility wrapper expected by tests
+    def process_complex(self, config):
+        """Compatibility wrapper: apply simple transformations described by config and return result."""
+        try:
+            input_data = config.get("input_data", []) if isinstance(config, dict) else []
+            result = list(input_data)
+            for t in config.get("transformations", []) if isinstance(config, dict) else []:
+                if t.get("type") == "scale" and "factor" in t:
+                    result = [x * t["factor"] for x in result]
+                if t.get("type") == "offset" and "value" in t:
+                    result = [x + t["value"] for x in result]
+            return {"processed": result}
+        except Exception as e:
+            return {"error": str(e)}
+
 # 数学计算类
 class MathOperations:
     def __init__(self, base_value=0):
diff --git a/src/ast_visitor.cpp b/src/ast_visitor.cpp
new file mode 100644
index 0000000..9212dad
--- /dev/null
+++ b/src/ast_visitor.cpp
@@ -0,0 +1,2677 @@
+/**
+ * @file ast_visitor.cpp
+ * @brief ANTLR语法树访问者实现
+ */
+
+#include "ast_visitor.h"
+#include "antlr/PyScriptLexer.h"
+#include "antlr/PyScriptParser.h"
+#include <fstream>
+#include <sstream>
+#include <iostream>
+#include <stdexcept>
+#include <cmath>
+#include <algorithm>
+#include <unordered_map>
+#include "dynamic_python_caller.h"
+
+using namespace antlr4;
+using namespace std;
+using namespace script_interpreter;
+
+// 构造函数
+AstVisitor::AstVisitor(VariableManager& variable_manager,
+                       ErrorHandler& error_handler,
+                       Logger& logger,
+                       PythonBridge& python_bridge,
+                       ExpressionEvaluator& expression_evaluator)
+    : variable_manager_(variable_manager),
+      error_handler_(error_handler),
+      logger_(logger),
+      python_bridge_(python_bridge),
+      expression_evaluator_(expression_evaluator),
+      result_(nullptr),
+      defining_function_(false) {
+}
+
+// 报告错误
+void AstVisitor::reportError(const std::string& message,
+                            ScriptErrorType type,
+                            ScriptErrorCode code,
+                            int line, int column) {
+    error_handler_.reportError(message, type, code, line, column);
+    logger_.error(std::string("Script Error: ") + message + " [Type=" + to_string(static_cast<int>(type))
+              + ", Code=" + to_string(static_cast<int>(code)) + ", Line=" + to_string(line) + ", Col=" + to_string(column) + "]");
+}
+
+void AstVisitor::reportError(const std::string& message, antlr4::ParserRuleContext *ctx,
+                            ScriptErrorType type,
+                            ScriptErrorCode code) {
+    int line = -1, column = -1;
+    if (ctx) {
+        auto token = ctx->getStart();
+        if (token) {
+            line = token->getLine();
+            column = token->getCharPositionInLine();
+        }
+    }
+    error_handler_.reportError(message, type, code, line, column);
+    logger_.error(std::string("Script Error: ") + message + " [Type=" + to_string(static_cast<int>(type))
+              + ", Code=" + to_string(static_cast<int>(code)) + ", Line=" + to_string(line) + ", Col=" + to_string(column) + "]");
+}
+
+// 求值表达式
+shared_ptr<ScriptValue> AstVisitor::evaluateExpression(PyScriptParser::ExpressionContext *ctx) {
+    if (!ctx) {
+        logger_.error("evaluateExpression: ctx is null!");
+        return nullptr;
+    }
+    auto result = visit(ctx);
+    try {
+        return any_cast<shared_ptr<ScriptValue>>(result);
+    } catch (const bad_any_cast&) {
+        return nullptr;
+    }
+}
+
+// 获取变量
+shared_ptr<ScriptValue> AstVisitor::getVariable(const std::string& name) {
+    return variable_manager_.getVariable(name);
+}
+
+// 设置变量
+void AstVisitor::setVariable(const std::string& name, shared_ptr<ScriptValue> value) {
+    variable_manager_.setVariable(name, value);
+}
+
+// 执行代码块
+shared_ptr<ScriptValue> AstVisitor::executeBlock(PyScriptParser::BlockContext *ctx) {
+    if (!ctx) {
+        return nullptr;
+    }
+    
+    if (ctx->statement().empty()) {
+        return ScriptValue::createNull();
+    }
+    
+    // 执行代码块中的所有语句
+    shared_ptr<ScriptValue> lastResult = nullptr;
+    for (auto stmt : ctx->statement()) {
+        auto result = visit(stmt);
+        if (error_handler_.hasError()) {
+            break;
+        }
+        
+        try {
+            lastResult = any_cast<shared_ptr<ScriptValue>>(result);
+        } catch (const bad_any_cast&) {
+            // 忽略非ScriptValue结果
+        }
+    }
+    
+    return lastResult ? lastResult : ScriptValue::createNull();
+}
+
+// ========== Visitor方法实现 ==========
+
+any AstVisitor::visitProgram(PyScriptParser::ProgramContext *ctx) {
+    // 执行所有语句
+    for (auto stmt : ctx->statement()) {
+        this->visit(stmt);
+        if (error_handler_.hasError()) {
+            break;
+        }
+    }
+    
+    // 如果没有return语句，最后一条语句的值作为结果
+    if (result_ == nullptr && ctx->statement().size() > 0) {
+        // 尝试获取最后一个表达式语句的结果
+        auto lastStmt = ctx->statement().back();
+        // 使用ANTLR上下文方法检查是否是expressionStatement
+        auto exprStmt = lastStmt->expressionStatement();
+        if (exprStmt) {
+            result_ = evaluateExpression(exprStmt->expression());
+        }
+    }
+    
+    return any();
+}
+
+any AstVisitor::visitStatement(PyScriptParser::StatementContext *ctx) {
+    // 根据实际的子节点类型进行分发
+    if (ctx->importStatement()) {
+        return this->visit(ctx->importStatement());
+    } else if (ctx->functionDefinition()) {
+        return this->visit(ctx->functionDefinition());
+    } else if (ctx->assignment()) {
+        return this->visit(ctx->assignment());
+    } else if (ctx->ifStatement()) {
+        return this->visit(ctx->ifStatement());
+    } else if (ctx->whileStatement()) {
+        return this->visit(ctx->whileStatement());
+    } else if (ctx->forStatement()) {
+        return this->visit(ctx->forStatement());
+    } else if (ctx->returnStatement()) {
+        return this->visit(ctx->returnStatement());
+    } else if (ctx->expressionStatement()) {
+        return this->visit(ctx->expressionStatement());
+    }
+    
+    reportError("Unknown statement type", ctx);
+    return any();
+}
+
+any AstVisitor::visitImportStatement(PyScriptParser::ImportStatementContext *ctx) {
+    logger_.debug("visitImportStatement called");
+    
+    try {
+        auto dottedNameCtx = ctx->dottedName();
+        if (!dottedNameCtx) {
+            reportError("Import statement must specify a module name", ctx);
+            return any();
+        }
+        
+        // 获取模块名
+        string moduleName = dottedNameCtx->getText();
+        logger_.debug(std::string("Importing module: ") + moduleName);
+        
+        // 检查是否有别名
+        string alias;
+        if (ctx->IDENTIFIER()) {
+            alias = ctx->IDENTIFIER()->getText();
+            logger_.debug(std::string("Alias: ") + alias);
+        }
+        
+        // 导入Python模块
+        logger_.debug("Calling py::module_::import...");
+        py::module_ module = py::module_::import(moduleName.c_str());
+        logger_.info(std::string("Module imported successfully: ") + moduleName);
+        
+        // 存储模块到VariableManager
+        variable_manager_.importModule(moduleName, module);
+        
+        // 存储模块引用到变量
+        if (!alias.empty()) {
+            variable_manager_.setVariable(alias, ScriptValue::createPythonObject(module));
+            logger_.debug(std::string("Module stored in variables with alias: ") + alias);
+        } else {
+            // 使用模块名的最后一部分作为变量名
+            size_t dotPos = moduleName.find_last_of('.');
+            string shortName = (dotPos != string::npos) ? 
+                              moduleName.substr(dotPos + 1) : moduleName;
+            variable_manager_.setVariable(shortName, ScriptValue::createPythonObject(module));
+            logger_.debug(std::string("Module stored in variables with short name: ") + shortName);
+        }
+        
+        // 验证存储
+        logger_.debug("Verifying storage...");
+        if (!alias.empty()) {
+            auto var = variable_manager_.getVariable(alias);
+            if (var) {
+                logger_.debug(std::string("Variable '") + alias + "' found in variables map");
+            } else {
+                logger_.error(std::string("ERROR: Variable '") + alias + "' NOT found in variables map!");
+            }
+        }
+        
+    } catch (const py::error_already_set& e) {
+        logger_.error(std::string("Python import error: ") + e.what());
+        reportError("Failed to import module: " + string(e.what()), ctx);
+    } catch (const exception& e) {
+        logger_.error(std::string("General import error: ") + e.what());
+        reportError("Import error: " + string(e.what()), ctx);
+    }
+    
+    return any();
+}
+
+// 其他visitor方法将逐步从script_interpreter.cpp迁移过来
+// 由于时间有限，我们先迁移以上几个方法作为示例
+
+any AstVisitor::visitFunctionDefinition(PyScriptParser::FunctionDefinitionContext *ctx) {
+    logger_.debug("visitFunctionDefinition called");
+    
+    string funcName = ctx->IDENTIFIER()->getText();
+    logger_.debug(std::string("Function name: ") + funcName);
+    
+    // 获取参数列表（支持默认值、*args 和 **kwargs）
+    vector<string> paramNames;
+    if (ctx->parameterList()) {
+        for (auto* p : ctx->parameterList()->parameter()) {
+            if (p->IDENTIFIER() && !p->MUL() && !p->DOUBLE_STAR()) {
+                std::string name = p->IDENTIFIER()->getText();
+                if (p->ASSIGN() && p->expression()) {
+                    // 使用原始文本作为默认值表示
+                    std::string defText = p->expression()->getText();
+                    paramNames.push_back(name + "=" + defText);
+                } else {
+                    paramNames.push_back(name);
+                }
+            } else if (p->MUL() && p->IDENTIFIER()) {
+                paramNames.push_back("*" + p->IDENTIFIER()->getText());
+            } else if (p->DOUBLE_STAR() && p->IDENTIFIER()) {
+                paramNames.push_back("**" + p->IDENTIFIER()->getText());
+            }
+        }
+    }
+    
+    // 获取函数体
+    auto blockCtx = ctx->block();
+    if (!blockCtx) {
+        reportError("Function definition missing body", ctx);
+        return any();
+    }
+    
+    // 获取函数体中的所有语句
+    auto statements = blockCtx->statement();
+    logger_.debug(std::string("Number of statements in function body: ") + std::to_string(statements.size()));
+    
+    // 打印语句类型信息
+    for (size_t i = 0; i < statements.size(); ++i) {
+        auto stmt = statements[i];
+        logger_.debug(std::string("Statement ") + std::to_string(i) + " type: " + typeid(*stmt).name());
+        logger_.debug(std::string("Statement ") + std::to_string(i) + " text: " + stmt->getText());
+        
+        // 检查是否是return语句
+        auto returnStmt = dynamic_cast<PyScriptParser::ReturnStatementContext*>(stmt);
+        if (returnStmt) {
+            logger_.debug(std::string("Statement ") + std::to_string(i) + " is a return statement");
+            if (returnStmt->expression()) {
+                logger_.debug(std::string("Return expression: ") + returnStmt->expression()->getText());
+            }
+        }
+    }
+    
+    // 设置标志防止在函数定义体中报错
+    defining_function_ = true;
+    
+    // 构建函数定义字符串
+    string funcDef = "def " + funcName + "(";
+    for (size_t i = 0; i < paramNames.size(); ++i) {
+        if (i > 0) funcDef += ", ";
+        funcDef += paramNames[i];
+    }
+    funcDef += "):\n";
+    
+    if (statements.empty()) {
+        funcDef += "    pass";
+        logger_.warn("Warning: Function body is empty, using 'pass'");
+    } else {
+    // 遍历所有语句，将它们添加到函数体中
+    for (auto stmt : statements) {
+        // 检查是否是return语句 - 使用StatementContext的方法
+        auto returnStmt = stmt->returnStatement();
+        if (returnStmt) {
+            // 获取return语句中的表达式
+            auto exprCtx = returnStmt->expression();
+            if (exprCtx) {
+                string exprText = exprCtx->getText();
+                funcDef += "    return " + exprText + "\n";
+            } else {
+                funcDef += "    return\n";
+            }
+        } else {
+            // 其他语句，使用原始文本
+            string stmtText = stmt->getText();
+            // 移除末尾的分号（如果有）
+            if (!stmtText.empty() && stmtText.back() == ';') {
+                stmtText.pop_back();
+            }
+            funcDef += "    " + stmtText + "\n";
+        }
+    }
+    }
+    
+    logger_.debug(std::string("Function definition string:\n") + funcDef + "\n");
+    
+    // 在Python中执行函数定义
+    py::dict globals = py::globals();
+    // 确保globals包含__builtins__
+    if (!globals.contains("__builtins__")) {
+        try {
+            py::module_ builtins = py::module_::import("builtins");
+            globals["__builtins__"] = builtins;
+        } catch (...) {
+            // 忽略错误
+        }
+    }
+    
+    try {
+        py::object builtins_module = py::module_::import("builtins");
+        builtins_module.attr("exec")(funcDef, globals, globals);
+        py::object func = globals[funcName.c_str()];
+        variable_manager_.setVariable(funcName, ScriptValue::fromPythonObject(func));
+        logger_.info(std::string("Function defined: ") + funcName);
+    } catch (const py::error_already_set& e) {
+        reportError("Failed to define function " + funcName + ": " + string(e.what()), ctx);
+    }
+    
+    // 重置标志
+    defining_function_ = false;
+    // 返回非空值阻止访问子节点
+    return any(true);
+}
+
+any AstVisitor::visitParameterList(PyScriptParser::ParameterListContext *ctx) {
+    // 参数列表已经在函数定义中处理
+    return any();
+}
+
+any AstVisitor::visitIfStatement(PyScriptParser::IfStatementContext *ctx) {
+    logger_.debug("visitIfStatement called");
+
+    auto exprCtx = ctx->expression();
+    if (!exprCtx) {
+        reportError("If statement condition is missing", ctx);
+        return any();
+    }
+
+    auto condValue = evaluateExpression(exprCtx);
+    if (!condValue) {
+        reportError("Cannot evaluate condition", ctx);
+        return any();
+    }
+
+    if (expression_evaluator_.isTruthy(condValue)) {
+        auto thenBlock = ctx->block(0);
+        if (thenBlock) {
+            return this->visit(thenBlock);
+        }
+    } else if (ctx->block().size() > 1) {
+        auto elseBlock = ctx->block(1);
+        if (elseBlock) {
+            return this->visit(elseBlock);
+        }
+    }
+
+    return any();
+}
+
+any AstVisitor::visitWhileStatement(PyScriptParser::WhileStatementContext *ctx) {
+    while (true) {
+        auto condValue = evaluateExpression(ctx->expression());
+
+        if (!condValue) {
+            reportError("Cannot evaluate condition", ctx);
+            break;
+        }
+
+        if (!expression_evaluator_.isTruthy(condValue)) {
+            break;
+        }
+
+        visit(ctx->block());
+
+        if (error_handler_.hasError()) {
+            break;
+        }
+    }
+
+    return any();
+}
+
+any AstVisitor::visitReturnStatement(PyScriptParser::ReturnStatementContext *ctx) {
+    // 如果正在定义函数，则跳过求值，只返回占位符
+    if (defining_function_) {
+        logger_.debug("Skipping return statement evaluation during function definition");
+        return any();
+    }
+
+    if (ctx->expression()) {
+        result_ = evaluateExpression(ctx->expression());
+    } else {
+        result_ = ScriptValue::createNull();
+    }
+    return any();
+}
+
+any AstVisitor::visitBlock(PyScriptParser::BlockContext *ctx) {
+    if (ctx->statement().empty()) {
+        // 空代码块
+        return any();
+    }
+
+    // 执行代码块中的所有语句
+    for (auto stmt : ctx->statement()) {
+        visit(stmt);
+        if (error_handler_.hasError()) {
+            break;
+        }
+    }
+
+    return any();
+}
+
+any AstVisitor::visitAssignment(PyScriptParser::AssignmentContext *ctx) {
+    // 有三种赋值形式：标识符赋值、属性赋值、下标赋值
+    if (ctx->IDENTIFIER()) {
+        // 标识符赋值: IDENTIFIER assignmentOperator expression
+        string varName = ctx->IDENTIFIER()->getText();
+        auto op = ctx->assignmentOperator();
+        if (!op) {
+            reportError("Missing assignment operator", ctx);
+            return any();
+        }
+        
+        auto rightExpr = ctx->expression(); // 右侧表达式
+        if (!rightExpr) {
+            reportError("Missing right-hand side expression", ctx);
+            return any();
+        }
+        
+        auto rightValue = evaluateExpression(rightExpr);
+        if (!rightValue) {
+            reportError("Cannot evaluate right-hand side", ctx);
+            return any();
+        }
+        
+        string opText = op->getText();
+        if (opText == "=") {
+            // 简单赋值
+            variable_manager_.setVariable(varName, rightValue);
+            try {
+                if (rightValue) {
+                    logger_.debug(std::string("Assigned variable '") + varName + "' = " + rightValue->toString());
+                } else {
+                    logger_.debug(std::string("Assigned variable '") + varName + "' = <null>");
+                }
+            } catch (...) {
+                logger_.debug(std::string("Assigned variable '") + varName + "' (no toString)");
+            }
+        } else {
+            // 复合赋值操作符
+            auto leftVal = getVariable(varName);
+            if (!leftVal) {
+                reportError("Variable '" + varName + "' not defined for compound assignment", ctx);
+                return any();
+            }
+            
+            // 执行复合运算
+            string baseOp = opText.substr(0, opText.size() - 1); // 去掉'='
+            auto result = expression_evaluator_.evaluateBinaryOperation(baseOp, leftVal, rightValue);
+            if (!result) {
+                reportError("Unsupported compound assignment operator: " + opText, ctx);
+                return any();
+            }
+            
+            variable_manager_.setVariable(varName, result);
+        }
+    } else if (ctx->attributeAccess()) {
+        // 属性赋值: attributeAccess '=' expression
+        auto attrCtx = ctx->attributeAccess();
+        auto primaryCtx = attrCtx->primaryExpression();
+        if (!primaryCtx) {
+            reportError("Attribute assignment missing object", ctx, ScriptErrorType::Runtime, ScriptErrorCode::Unknown);
+            return any();
+        }
+
+        auto objectAny = visit(primaryCtx);
+        shared_ptr<ScriptValue> objectValue;
+        try {
+            objectValue = any_cast<shared_ptr<ScriptValue>>(objectAny);
+        } catch (const bad_any_cast&) {
+            reportError("Cannot evaluate object in attribute assignment", ctx, ScriptErrorType::Runtime, ScriptErrorCode::Unknown);
+            return any();
+        }
+
+        if (!objectValue) {
+            reportError("Cannot evaluate object in attribute assignment", ctx, ScriptErrorType::Runtime, ScriptErrorCode::Unknown);
+            return any();
+        }
+
+        auto identifier = attrCtx->IDENTIFIER();
+        if (!identifier) {
+            reportError("Missing identifier in attribute assignment", ctx, ScriptErrorType::Syntax, ScriptErrorCode::InvalidSyntax);
+            return any();
+        }
+        string memberName = identifier->getText();
+
+        auto rightExpr = ctx->expression();
+        if (!rightExpr) {
+            reportError("Missing right-hand side expression", ctx, ScriptErrorType::Syntax, ScriptErrorCode::InvalidSyntax);
+            return any();
+        }
+
+        auto rightValue = evaluateExpression(rightExpr);
+        if (!rightValue) {
+            reportError("Cannot evaluate right-hand side", ctx, ScriptErrorType::Runtime, ScriptErrorCode::Unknown);
+            return any();
+        }
+
+        // 执行属性赋值
+        if (objectValue->isPythonObject()) {
+            py::object pyObj = objectValue->getPythonObject();
+            try {
+                py::object pyVal = rightValue->toPythonObject();
+                pyObj.attr(memberName.c_str()) = pyVal;
+                return any(rightValue);
+            } catch (const py::error_already_set& e) {
+                reportError(string("Python attribute assignment error: ") + e.what(), ctx, ScriptErrorType::Python, ScriptErrorCode::PythonException);
+                return any();
+            }
+        } else {
+            // 非Python对象，尝试通过ScriptValue的setMember方法
+            try {
+                objectValue->setMember(memberName, rightValue);
+                return any(rightValue);
+            } catch (const exception& e) {
+                reportError(string("Attribute assignment error: ") + e.what(), ctx, ScriptErrorType::Runtime, ScriptErrorCode::UnsupportedOperation);
+                return any();
+            }
+        }
+    } else if (ctx->subscriptAccess()) {
+        // 下标赋值: subscriptAccess '=' expression
+        auto subscriptCtx = ctx->subscriptAccess();
+        auto primaryCtx = subscriptCtx->primaryExpression();
+        if (!primaryCtx) {
+            reportError("Subscript access missing object", ctx);
+            return any();
+        }
+        
+        auto objectAny = visit(primaryCtx);
+        shared_ptr<ScriptValue> objectValue;
+        try {
+            objectValue = any_cast<shared_ptr<ScriptValue>>(objectAny);
+        } catch (const bad_any_cast&) {
+            reportError("Cannot evaluate object in subscript assignment", ctx);
+            return any();
+        }
+        
+        if (!objectValue) {
+            reportError("Cannot evaluate object in subscript assignment", ctx);
+            return any();
+        }
+        
+        auto indexExpr = subscriptCtx->expression();
+        if (!indexExpr) {
+            reportError("Missing subscript index", ctx);
+            return any();
+        }
+        
+        auto indexValue = evaluateExpression(indexExpr);
+        if (!indexValue) {
+            reportError("Cannot evaluate subscript index", ctx);
+            return any();
+        }
+        
+        // 对于下标赋值，直接获取右侧表达式（语法是 subscriptAccess '=' expression）
+        auto rightExpr = ctx->expression(); // 右侧表达式
+        if (!rightExpr) {
+            reportError("Missing right-hand side expression", ctx);
+            return any();
+        }
+        
+        auto rightValue = evaluateExpression(rightExpr);
+        if (!rightValue) {
+            reportError("Cannot evaluate right-hand side", ctx);
+            return any();
+        }
+        
+        // 执行下标赋值
+        if (objectValue->isPythonObject()) {
+            py::object pyObj = objectValue->getPythonObject();
+            try {
+                py::object pyIndex = indexValue->toPythonObject();
+                py::object pyRight = rightValue->toPythonObject();
+                pyObj[pyIndex] = pyRight;
+                // 下标赋值不产生新值，返回右侧值
+                return any(rightValue);
+            } catch (const py::error_already_set& e) {
+                reportError("Python subscript assignment error: " + string(e.what()), ctx);
+                return any();
+            }
+        } else if (objectValue->isList()) {
+            // 列表赋值
+            // 索引必须是整数
+            if (!indexValue->isInteger()) {
+                reportError("List index must be an integer", ctx);
+                return any();
+            }
+            
+            long long index = indexValue->getInteger();
+            
+            if (index < 0 || index >= static_cast<long long>(objectValue->listSize())) {
+                reportError("List index out of bounds: " + to_string(index) + 
+                           " (list size: " + to_string(objectValue->listSize()) + ")", ctx);
+                return any();
+            }
+            
+            // 更新列表元素
+            objectValue->setAt(static_cast<size_t>(index), rightValue);
+            return any(rightValue);
+        } else if (objectValue->isDictionary()) {
+            // 使用ScriptValue的setKey方法
+            if (!indexValue->isString()) {
+                reportError("Dictionary key must be a string", ctx);
+                return any();
+            }
+            string key = indexValue->getString();
+            objectValue->setKey(key, rightValue);
+            return any(rightValue);
+        } else {
+            reportError("Subscript assignment not supported for this type", ctx);
+            return any();
+        }
+    }
+    
+    return any();
+}
+
+any AstVisitor::visitAssignmentOperator(PyScriptParser::AssignmentOperatorContext *ctx) {
+    // 赋值操作符已经在visitAssignment中处理
+    return any();
+}
+
+any AstVisitor::visitExpressionStatement(PyScriptParser::ExpressionStatementContext *ctx) {
+    auto value = evaluateExpression(ctx->expression());
+    // 表达式语句的值可以忽略
+    return any(value);
+}
+
+any AstVisitor::visitExpression(PyScriptParser::ExpressionContext *ctx) {
+    // expression: assignment | ternaryExpression
+    if (ctx->assignment()) {
+        return visit(ctx->assignment());
+    } else if (ctx->ternaryExpression()) {
+        return visit(ctx->ternaryExpression());
+    }
+    
+    reportError("Invalid expression", ctx);
+    return any();
+}
+
+any AstVisitor::visitTernaryExpression(PyScriptParser::TernaryExpressionContext *ctx) {
+    logger_.debug("visitTernaryExpression called");
+    
+    // 检查是否有三元操作符
+    if (ctx->children.size() == 1) {
+        // 没有三元操作符，直接返回逻辑或表达式
+        auto logicalOrExprs = ctx->logicalOrExpression();
+        if (!logicalOrExprs.empty()) {
+            return visit(logicalOrExprs[0]);
+        } else {
+            reportError("Missing logical or expression in ternary expression", ctx);
+            return any();
+        }
+    }
+    
+    // 检查是Python风格 (if-else) 还是C风格 (?:)
+    bool pythonStyle = false;
+    for (size_t i = 0; i < ctx->children.size(); ++i) {
+        if (ctx->children[i]->getText() == "if") {
+            pythonStyle = true;
+            break;
+        }
+    }
+    
+    if (pythonStyle) {
+        // Python风格: logicalOrExpression 'if' logicalOrExpression 'else' ternaryExpression
+        std::vector<PyScriptParser::LogicalOrExpressionContext*> logicalOrExprs;
+        PyScriptParser::TernaryExpressionContext* falseExpr = nullptr;
+        
+        for (auto child : ctx->children) {
+            auto logicalOr = dynamic_cast<PyScriptParser::LogicalOrExpressionContext*>(child);
+            if (logicalOr) {
+                logicalOrExprs.push_back(logicalOr);
+            }
+            auto ternary = dynamic_cast<PyScriptParser::TernaryExpressionContext*>(child);
+            if (ternary && child != ctx) {
+                falseExpr = ternary;
+            }
+        }
+        
+        if (logicalOrExprs.size() >= 2 && falseExpr) {
+            auto trueExprCtx = logicalOrExprs[0];
+            auto condExprCtx = logicalOrExprs[1];
+            
+            auto condAny = visit(condExprCtx);
+            shared_ptr<ScriptValue> condValue;
+            try {
+                condValue = any_cast<shared_ptr<ScriptValue>>(condAny);
+            } catch (const bad_any_cast&) {
+                reportError("Cannot evaluate condition in Python-style ternary expression", ctx);
+                return any();
+            }
+            
+            if (!condValue) {
+                reportError("Cannot evaluate condition in Python-style ternary expression", ctx);
+                return any();
+            }
+            
+            if (expression_evaluator_.isTruthy(condValue)) {
+                return visit(trueExprCtx);
+            } else {
+                return visit(falseExpr);
+            }
+        } else {
+            reportError("Invalid Python-style ternary expression", ctx);
+            return any();
+        }
+    } else {
+        // C风格：condition ? trueExpr : falseExpr
+        auto logicalOrExprs = ctx->logicalOrExpression();
+        if (logicalOrExprs.empty()) {
+            reportError("Missing condition in C-style ternary expression", ctx);
+            return any();
+        }
+        auto condExprCtx = logicalOrExprs[0];
+        PyScriptParser::ExpressionContext* trueExprCtx = nullptr;
+        PyScriptParser::TernaryExpressionContext* falseExprCtx = nullptr;
+        
+        for (auto child : ctx->children) {
+            if (!trueExprCtx) {
+                auto expr = dynamic_cast<PyScriptParser::ExpressionContext*>(child);
+                if (expr) {
+                    trueExprCtx = expr;
+                    continue;
+                }
+            }
+            if (!falseExprCtx) {
+                auto ternary = dynamic_cast<PyScriptParser::TernaryExpressionContext*>(child);
+                if (ternary && child != ctx) {
+                    falseExprCtx = ternary;
+                }
+            }
+        }
+        
+        if (condExprCtx && trueExprCtx && falseExprCtx) {
+            auto condAny = visit(condExprCtx);
+            shared_ptr<ScriptValue> condValue;
+            try {
+                condValue = any_cast<shared_ptr<ScriptValue>>(condAny);
+            } catch (const bad_any_cast&) {
+                reportError("Cannot evaluate condition in ternary expression", ctx);
+                return any();
+            }
+            
+            if (!condValue) {
+                reportError("Cannot evaluate condition in ternary expression", ctx);
+                return any();
+            }
+            
+            if (expression_evaluator_.isTruthy(condValue)) {
+                return evaluateExpression(trueExprCtx);
+            } else {
+                return visit(falseExprCtx);
+            }
+        } else {
+            reportError("Invalid C-style ternary expression", ctx);
+            return any();
+        }
+    }
+}
+
+any AstVisitor::visitLogicalOrExpression(PyScriptParser::LogicalOrExpressionContext *ctx) {
+    auto logicalAndExprs = ctx->logicalAndExpression();
+    if (logicalAndExprs.size() == 1) {
+        return this->visit(logicalAndExprs[0]);
+    }
+    
+    // 处理多个逻辑或表达式
+    shared_ptr<ScriptValue> result;
+    for (auto expr : logicalAndExprs) {
+        auto valAny = visit(expr);
+        shared_ptr<ScriptValue> val;
+        try {
+            val = any_cast<shared_ptr<ScriptValue>>(valAny);
+        } catch (const bad_any_cast&) {
+            reportError("Cannot evaluate logical OR expression", ctx);
+            return any();
+        }
+        if (!val) {
+            reportError("Cannot evaluate logical OR expression", ctx);
+            return any();
+        }
+        
+        if (expression_evaluator_.isTruthy(val)) {
+            result = val;
+            break;
+        }
+        
+        if (!result) {
+            result = val;
+        }
+    }
+    
+    return any(result);
+}
+
+any AstVisitor::visitLogicalAndExpression(PyScriptParser::LogicalAndExpressionContext *ctx) {
+    auto equalityExprs = ctx->equalityExpression();
+    if (equalityExprs.size() == 1) {
+        return this->visit(equalityExprs[0]);
+    }
+    
+    // 处理多个逻辑与表达式
+    shared_ptr<ScriptValue> result;
+    for (auto expr : equalityExprs) {
+        auto valAny = visit(expr);
+        shared_ptr<ScriptValue> val;
+        try {
+            val = any_cast<shared_ptr<ScriptValue>>(valAny);
+        } catch (const bad_any_cast&) {
+            reportError("Cannot evaluate logical AND expression", ctx);
+            return any();
+        }
+        if (!val) {
+            reportError("Cannot evaluate logical AND expression", ctx);
+            return any();
+        }
+        
+        if (!expression_evaluator_.isTruthy(val)) {
+            result = val;
+            break;
+        }
+        
+        if (!result) {
+            result = val;
+        }
+    }
+    
+    return any(result);
+}
+
+any AstVisitor::visitEqualityExpression(PyScriptParser::EqualityExpressionContext *ctx) {
+    auto relationalExprs = ctx->relationalExpression();
+    if (relationalExprs.size() == 1) {
+        return this->visit(relationalExprs[0]);
+    }
+    
+    // 处理相等性比较
+    auto leftAny = visit(relationalExprs[0]);
+    shared_ptr<ScriptValue> left;
+    try {
+        left = any_cast<shared_ptr<ScriptValue>>(leftAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate left side of equality expression", ctx);
+        return any();
+    }
+    if (!left) {
+        reportError("Cannot evaluate left side of equality expression", ctx);
+        return any();
+    }
+    
+    for (size_t i = 1; i < relationalExprs.size(); ++i) {
+        auto rightAny = visit(relationalExprs[i]);
+        shared_ptr<ScriptValue> right;
+        try {
+            right = any_cast<shared_ptr<ScriptValue>>(rightAny);
+        } catch (const bad_any_cast&) {
+            reportError("Cannot evaluate right side of equality expression", ctx);
+            return any();
+        }
+        if (!right) {
+            reportError("Cannot evaluate right side of equality expression", ctx);
+            return any();
+        }
+        
+        // 获取操作符
+        string op = ctx->children[2*i - 1]->getText();
+        auto result = expression_evaluator_.evaluateBinaryOperation(op, left, right);
+        if (!result) {
+            reportError("Unsupported equality operator: " + op, ctx);
+            return any();
+        }
+        
+        left = result;
+    }
+    
+    return any(left);
+}
+
+any AstVisitor::visitRelationalExpression(PyScriptParser::RelationalExpressionContext *ctx) {
+    auto additiveExprs = ctx->additiveExpression();
+    if (additiveExprs.size() == 1) {
+        return this->visit(additiveExprs[0]);
+    }
+    
+    // 处理关系比较
+    auto leftAny = visit(additiveExprs[0]);
+    shared_ptr<ScriptValue> left;
+    try {
+        left = any_cast<shared_ptr<ScriptValue>>(leftAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate left side of relational expression", ctx);
+        return any();
+    }
+    if (!left) {
+        reportError("Cannot evaluate left side of relational expression", ctx);
+        return any();
+    }
+    
+    for (size_t i = 1; i < additiveExprs.size(); ++i) {
+        auto rightAny = visit(additiveExprs[i]);
+        shared_ptr<ScriptValue> right;
+        try {
+            right = any_cast<shared_ptr<ScriptValue>>(rightAny);
+        } catch (const bad_any_cast&) {
+            reportError("Cannot evaluate right side of relational expression", ctx);
+            return any();
+        }
+        if (!right) {
+            reportError("Cannot evaluate right side of relational expression", ctx);
+            return any();
+        }
+        
+        // 获取操作符
+        string op = ctx->children[2*i - 1]->getText();
+        auto result = expression_evaluator_.evaluateBinaryOperation(op, left, right);
+        if (!result) {
+            reportError("Unsupported relational operator: " + op, ctx);
+            return any();
+        }
+        
+        left = result;
+    }
+    
+    return any(left);
+}
+
+any AstVisitor::visitAdditiveExpression(PyScriptParser::AdditiveExpressionContext *ctx) {
+    auto multiplicativeExprs = ctx->multiplicativeExpression();
+    if (multiplicativeExprs.size() == 1) {
+        return this->visit(multiplicativeExprs[0]);
+    }
+    
+    // 处理加减运算
+    auto leftAny = visit(multiplicativeExprs[0]);
+    shared_ptr<ScriptValue> left;
+    try {
+        left = any_cast<shared_ptr<ScriptValue>>(leftAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate left side of additive expression", ctx);
+        return any();
+    }
+    if (!left) {
+        reportError("Cannot evaluate left side of additive expression", ctx);
+        return any();
+    }
+    
+    for (size_t i = 1; i < multiplicativeExprs.size(); ++i) {
+        auto rightAny = visit(multiplicativeExprs[i]);
+        shared_ptr<ScriptValue> right;
+        try {
+            right = any_cast<shared_ptr<ScriptValue>>(rightAny);
+        } catch (const bad_any_cast&) {
+            reportError("Cannot evaluate right side of additive expression", ctx);
+            return any();
+        }
+        if (!right) {
+            reportError("Cannot evaluate right side of additive expression", ctx);
+            return any();
+        }
+        
+        // 获取操作符
+        string op = ctx->children[2*i - 1]->getText();
+        auto result = expression_evaluator_.evaluateBinaryOperation(op, left, right);
+        if (!result) {
+            reportError("Unsupported multiplicative operator: " + op, ctx);
+            return any();
+        }
+        
+        left = result;
+    }
+    
+    return any(left);
+}
+
+any AstVisitor::visitMultiplicativeExpression(PyScriptParser::MultiplicativeExpressionContext *ctx) {
+    auto powerExprs = ctx->powerExpression();
+    if (powerExprs.size() == 1) {
+        return this->visit(powerExprs[0]);
+    }
+    
+    // 处理乘除取模运算
+    auto leftAny = visit(powerExprs[0]);
+    shared_ptr<ScriptValue> left;
+    try {
+        left = any_cast<shared_ptr<ScriptValue>>(leftAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate left side of multiplicative expression", ctx);
+        return any();
+    }
+    if (!left) {
+        reportError("Cannot evaluate left side of multiplicative expression", ctx);
+        return any();
+    }
+    
+    for (size_t i = 1; i < powerExprs.size(); ++i) {
+        auto rightAny = visit(powerExprs[i]);
+        shared_ptr<ScriptValue> right;
+        try {
+            right = any_cast<shared_ptr<ScriptValue>>(rightAny);
+        } catch (const bad_any_cast&) {
+            reportError("Cannot evaluate right side of multiplicative expression", ctx);
+            return any();
+        }
+        if (!right) {
+            reportError("Cannot evaluate right side of multiplicative expression", ctx);
+            return any();
+        }
+        
+        // 获取操作符
+        string op = ctx->children[2*i - 1]->getText();
+        auto result = expression_evaluator_.evaluateBinaryOperation(op, left, right);
+        if (!result) {
+            reportError("Unsupported multiplicative operator: " + op, ctx);
+            return any();
+        }
+        
+        left = result;
+    }
+    
+    return any(left);
+}
+
+any AstVisitor::visitUnaryExpression(PyScriptParser::UnaryExpressionContext *ctx) {
+    auto callOrPrimaryCtx = ctx->callOrPrimary();
+    auto callOrPrimaryAny = this->visit(callOrPrimaryCtx);
+    shared_ptr<ScriptValue> callOrPrimaryValue;
+    try {
+        callOrPrimaryValue = any_cast<shared_ptr<ScriptValue>>(callOrPrimaryAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate expression in unary expression", ctx);
+        return any();
+    }
+    
+    if (!callOrPrimaryValue) {
+        reportError("Cannot evaluate expression in unary expression", ctx);
+        return any();
+    }
+    
+    // 检查是否有前缀操作符
+    if (ctx->children.size() > 1) {
+        string op = ctx->children[0]->getText();
+        auto result = expression_evaluator_.evaluateUnaryOperation(op, callOrPrimaryValue);
+        if (!result) {
+            reportError("Unsupported unary operator: " + op, ctx);
+            return any();
+        }
+        return any(result);
+    }
+    
+    return any(callOrPrimaryValue);
+}
+
+any AstVisitor::visitCallOrPrimary(PyScriptParser::CallOrPrimaryContext *ctx) {
+    logger_.debug("visitCallOrPrimary called");
+    
+    auto primary = ctx->primaryExpression();
+    if (!primary) {
+        reportError("Missing primary expression in callOrPrimary", ctx);
+        return any();
+    }
+    
+    // 获取primaryExpression的值
+    auto primaryAny = this->visit(primary);
+    shared_ptr<ScriptValue> currentValue;
+    try {
+        currentValue = any_cast<shared_ptr<ScriptValue>>(primaryAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate primary expression", ctx);
+        return any();
+    }
+    
+    if (!currentValue) {
+        reportError("Cannot evaluate primary expression", ctx);
+        return any();
+    }
+    
+    // 应用所有的postfix操作符
+    auto postfixOps = ctx->postfixOp();
+    for (auto postfixOp : postfixOps) {
+        // 检查postfixOp的类型
+        auto* attrOp = dynamic_cast<PyScriptParser::AttributeAccessOpContext*>(postfixOp);
+        auto* subscriptOp = dynamic_cast<PyScriptParser::SubscriptAccessOpContext*>(postfixOp);
+        auto* funcCallOp = dynamic_cast<PyScriptParser::FunctionCallOpContext*>(postfixOp);
+        
+        if (attrOp) {
+            // 属性访问: '.' IDENTIFIER
+            auto identifier = attrOp->IDENTIFIER();
+            if (!identifier) {
+                reportError("Missing identifier in attribute access", postfixOp);
+                return any();
+            }
+            string memberName = identifier->getText();
+            auto member = python_bridge_.getMember(currentValue, memberName);
+            if (!member) {
+                reportError("Object has no member: " + memberName, postfixOp);
+                return any();
+            }
+            currentValue = member;
+        } else if (subscriptOp) {
+            // 下标访问: '[' expression ']'
+            auto indexExpr = subscriptOp->expression();
+            if (!indexExpr) {
+                reportError("Missing index expression in subscript access", postfixOp);
+                return any();
+            }
+            auto indexValue = evaluateExpression(indexExpr);
+            if (!indexValue) {
+                reportError("Cannot evaluate subscript index", postfixOp);
+                return any();
+            }
+            
+            if (currentValue->isPythonObject()) {
+                py::object pyObj = currentValue->getPythonObject();
+                // 检查是否是函数对象，函数对象不可下标
+                if (py::isinstance<py::function>(pyObj)) {
+                    reportError("Cannot use function object as subscriptable", postfixOp);
+                    return any();
+                }
+                try {
+                    py::object pyIndex = indexValue->toPythonObject();
+                    py::object result = pyObj[pyIndex];
+                    currentValue = ScriptValue::fromPythonObject(result);
+                } catch (const py::error_already_set& e) {
+                    reportError("Python subscript error: " + string(e.what()), postfixOp);
+                    return any();
+                }
+            } else if (currentValue->isList()) {
+                auto& list = currentValue->getList();
+                // 索引必须是整数
+                if (!indexValue->isInteger()) {
+                    reportError("List index must be an integer", postfixOp);
+                    return any();
+                }
+                long long index = indexValue->getInteger();
+                if (index < 0 || index >= static_cast<long long>(list.size())) {
+                    reportError("List index out of bounds: " + to_string(index) + 
+                               " (list size: " + to_string(list.size()) + ")", postfixOp);
+                    return any();
+                }
+                currentValue = list[index];
+            } else if (currentValue->isDictionary()) {
+                auto& dict = currentValue->getDictionary();
+                // 索引必须是字符串
+                if (!indexValue->isString()) {
+                    reportError("Dictionary key must be a string", postfixOp);
+                    return any();
+                }
+                string key = indexValue->getString();
+                auto it = dict.find(key);
+                if (it == dict.end()) {
+                    reportError("Dictionary key not found: " + key, postfixOp);
+                    return any();
+                }
+                currentValue = it->second;
+            } else {
+                reportError("Subscript not supported for this type", postfixOp);
+                return any();
+            }
+        } else if (funcCallOp) {
+            // 函数调用: '(' argumentList? ')'
+            vector<shared_ptr<ScriptValue>> positional;
+            unordered_map<string, shared_ptr<ScriptValue>> keywords;
+            vector<shared_ptr<ScriptValue>> starPos;
+            vector<shared_ptr<ScriptValue>> starKw;
+
+            auto argList = funcCallOp->argumentList();
+            if (argList) {
+                for (auto* a : argList->argument()) {
+                    if (a->IDENTIFIER() && a->ASSIGN()) {
+                        auto val = evaluateExpression(a->expression());
+                        if (!val) { reportError("Cannot evaluate keyword argument", postfixOp); return any(); }
+                        keywords[a->IDENTIFIER()->getText()] = val;
+                        logger_.debug(std::string("Keyword arg: ") + a->IDENTIFIER()->getText());
+                    } else if (a->MUL()) {
+                        auto val = evaluateExpression(a->expression());
+                        if (!val) { reportError("Cannot evaluate * argument", postfixOp); return any(); }
+                        starPos.push_back(val);
+                        logger_.debug("Star positional arg detected (inline)");
+                    } else if (a->DOUBLE_STAR()) {
+                        auto val = evaluateExpression(a->expression());
+                        if (!val) { reportError("Cannot evaluate ** argument", postfixOp); return any(); }
+                        starKw.push_back(val);
+                        logger_.debug("Star keyword arg detected (inline)");
+                    } else if (a->expression() && a->expression()->assignment()) {
+                        // inline call used an assignment expression: treat as keyword arg
+                        auto assignCtx = a->expression()->assignment();
+                        std::string argText = a->getText();
+                        if (assignCtx && assignCtx->IDENTIFIER() && assignCtx->assignmentOperator()) {
+                            auto val = evaluateExpression(assignCtx->expression());
+                            if (!val) { reportError(std::string("Cannot evaluate keyword argument: ") + argText, postfixOp); return any(); }
+                            keywords[assignCtx->IDENTIFIER()->getText()] = val;
+                            logger_.debug(std::string("Inline keyword arg: ") + assignCtx->IDENTIFIER()->getText());
+                        } else {
+                            reportError(std::string("Invalid inline assignment argument: ") + argText, postfixOp);
+                            return any();
+                        }
+                    } else if (a->expression()) {
+                        std::string argText = a->getText();
+                        logger_.debug(std::string("Evaluating inline positional argument: ") + argText);
+                        auto val = evaluateExpression(a->expression());
+                        if (!val) { reportError(std::string("Cannot evaluate positional argument: ") + argText, postfixOp); return any(); }
+                        positional.push_back(val);
+                        logger_.debug(std::string("Positional arg=") + val->toString());
+                    } else {
+                        reportError("Invalid argument", postfixOp);
+                        return any();
+                    }
+                }
+            }
+
+            if (!currentValue->isPythonObject()) {
+                reportError("Cannot call non-function type", postfixOp);
+                return any();
+            }
+
+            try {
+                py::object pyFunc = currentValue->getPythonObject();
+
+                // 构建py::tuple
+                py::tuple pyTuple(positional.size());
+                size_t idx = 0;
+                for (auto &p : positional) {
+                    pyTuple[idx++] = p->toPythonObject();
+                }
+                // 处理 *args 展开 (inline)
+                for (auto &p : starPos) {
+                    if (p->isList()) {
+                        for (auto &elem : p->getList()) {
+                            py::list tmp = py::list(pyTuple);
+                            tmp.append(elem->toPythonObject());
+                            pyTuple = py::tuple(tmp);
+                        }
+                    } else if (p->isPythonObject()) {
+                        try {
+                            py::object pyObj = p->toPythonObject();
+                            if (py::isinstance<py::iterable>(pyObj)) {
+                                for (auto item : pyObj) {
+                                    py::list tmp = py::list(pyTuple);
+                                    tmp.append(item);
+                                    pyTuple = py::tuple(tmp);
+                                }
+                            } else {
+                                py::list tmp = py::list(pyTuple);
+                                tmp.append(pyObj);
+                                pyTuple = py::tuple(tmp);
+                            }
+                        } catch (...) {
+                            reportError("Failed to expand *args", postfixOp);
+                            return any();
+                        }
+                    } else {
+                        py::list tmp = py::list(pyTuple);
+                        tmp.append(p->toPythonObject());
+                        pyTuple = py::tuple(tmp);
+                    }
+                }
+
+                // 构建kwargs (inline)
+                py::dict pyKwargs;
+                for (auto &kv : keywords) {
+                    pyKwargs[kv.first.c_str()] = kv.second->toPythonObject();
+                }
+                // 处理 **kwargs 展开
+                for (auto &p : starKw) {
+                    if (p->isDictionary()) {
+                        for (auto &kv : p->getDictionary()) {
+                            pyKwargs[kv.first.c_str()] = kv.second->toPythonObject();
+                        }
+                    } else if (p->isPythonObject()) {
+                        try {
+                            py::object pyObj = p->toPythonObject();
+                            if (py::isinstance<py::dict>(pyObj)) {
+                                py::dict pyD = pyObj.cast<py::dict>();
+                                for (auto item : pyD) {
+                                    std::string key = py::str(item.first).cast<std::string>();
+                                    pyKwargs[key.c_str()] = item.second;
+                                }
+                            } else {
+                                reportError("** unpack requires a mapping", postfixOp);
+                                return any();
+                            }
+                        } catch (...) {
+                            reportError("Failed to expand **kwargs", postfixOp);
+                            return any();
+                        }
+                    } else {
+                        reportError("** unpack requires a mapping", postfixOp);
+                        return any();
+                    }
+                }
+
+                // 使用DynamicPythonCaller来调用函数以传递args和kwargs
+                py::object result = DynamicPythonCaller::callFunction(pyFunc, py::args(pyTuple), py::kwargs(pyKwargs));
+                currentValue = ScriptValue::fromPythonObject(result);
+            } catch (const py::error_already_set& e) {
+                reportError("Python function call error: " + string(e.what()), postfixOp);
+                return any();
+            } catch (const exception& e) {
+                reportError("Function call error: " + string(e.what()), postfixOp);
+                return any();
+            }
+        } else {
+            reportError("Unknown postfix operator type", postfixOp);
+            return any();
+        }
+    }
+    
+    return any(currentValue);
+}
+
+any AstVisitor::visitFunctionCall(PyScriptParser::FunctionCallContext *ctx) {
+    logger_.debug("visitFunctionCall called");
+    
+    // 新的语法允许更复杂的函数调用表达式
+    // 获取被调用对象：可以是dottedName、attributeAccess、subscriptAccess或括号表达式
+    antlr4::tree::ParseTree* callee = nullptr;
+    if (ctx->dottedName()) {
+        callee = ctx->dottedName();
+    } else if (ctx->attributeAccess()) {
+        callee = ctx->attributeAccess();
+    } else if (ctx->subscriptAccess()) {
+        callee = ctx->subscriptAccess();
+    } else if (ctx->expression()) {
+        // 括号表达式
+        callee = ctx->expression();
+    }
+    
+    if (!callee) {
+        reportError("Function call missing callee", ctx);
+        return any();
+    }
+    
+    // 计算被调用对象的值
+    auto calleeAny = this->visit(callee);
+    shared_ptr<ScriptValue> calleeValue;
+    try {
+        calleeValue = any_cast<shared_ptr<ScriptValue>>(calleeAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate function callee", ctx);
+        return any();
+    }
+    
+    if (!calleeValue) {
+        reportError("Cannot evaluate function callee", ctx);
+        return any();
+    }
+    
+    if (!calleeValue->isPythonObject()) {
+        reportError("Cannot call non-function type", ctx);
+        return any();
+    }
+    
+    // 收集参数（支持位置参数、关键字参数以及 * / ** 展开）
+    vector<shared_ptr<ScriptValue>> positional;
+    unordered_map<string, shared_ptr<ScriptValue>> keywords;
+    vector<shared_ptr<ScriptValue>> starPos;
+    vector<shared_ptr<ScriptValue>> starKw;
+
+    if (ctx->argumentList()) {
+        auto argCtxs = ctx->argumentList()->argument();
+        logger_.debug(std::string("Argument count: ") + std::to_string(argCtxs.size()));
+        for (size_t i = 0; i < argCtxs.size(); ++i) {
+            auto a = argCtxs[i];
+            std::string argText = a->getText();
+            // keyword form can be parsed either as Argument IDENTIFIER ASSIGN expression
+            // or as an assignment expression inside expression(). Handle both.
+            if (a->IDENTIFIER() && a->ASSIGN()) {
+                auto val = evaluateExpression(a->expression());
+                if (!val) { reportError(std::string("Cannot evaluate keyword argument: ") + argText, ctx); return any(); }
+                keywords[a->IDENTIFIER()->getText()] = val;
+                logger_.debug(std::string("Keyword arg: ") + a->IDENTIFIER()->getText());
+            } else if (a->expression() && a->expression()->assignment()) {
+                // expression is an assignment expression like IDENTIFIER = expr
+                auto assignCtx = a->expression()->assignment();
+                if (assignCtx && assignCtx->IDENTIFIER() && assignCtx->assignmentOperator()) {
+                    auto val = evaluateExpression(assignCtx->expression());
+                    if (!val) { reportError(std::string("Cannot evaluate keyword argument: ") + argText, ctx); return any(); }
+                    keywords[assignCtx->IDENTIFIER()->getText()] = val;
+                    logger_.debug(std::string("Keyword arg (assignment form): ") + assignCtx->IDENTIFIER()->getText());
+                } else {
+                    reportError(std::string("Invalid assignment argument: ") + argText, ctx);
+                    return any();
+                }
+            } else if (a->MUL()) {
+                auto val = evaluateExpression(a->expression());
+                if (!val) { reportError(std::string("Cannot evaluate * argument: ") + argText, ctx); return any(); }
+                starPos.push_back(val);
+                logger_.debug("Star positional arg detected");
+            } else if (a->DOUBLE_STAR()) {
+                auto val = evaluateExpression(a->expression());
+                if (!val) { reportError(std::string("Cannot evaluate ** argument: ") + argText, ctx); return any(); }
+                starKw.push_back(val);
+                logger_.debug("Star keyword arg detected");
+            } else if (a->expression()) {
+                logger_.debug(std::string("Evaluating positional argument expression: ") + argText);
+                auto val = evaluateExpression(a->expression());
+                if (!val) { reportError(std::string("Cannot evaluate positional argument: ") + argText, ctx); return any(); }
+                positional.push_back(val);
+                logger_.debug(std::string("Positional arg[") + std::to_string(i) + "]=" + val->toString());
+            } else {
+                reportError("Invalid argument", ctx);
+                return any();
+            }
+        }
+    }
+
+    try {
+        py::object pyFunc = calleeValue->getPythonObject();
+        logger_.debug(std::string("Python function type: ") + py::str(py::type::of(pyFunc)).cast<std::string>() );
+
+        // 构建py::tuple
+        py::tuple pyTuple(positional.size());
+        size_t idx = 0;
+        for (auto &p : positional) {
+            pyTuple[idx++] = p->toPythonObject();
+        }
+        // 处理 *args 展开
+        for (auto &p : starPos) {
+            if (p->isList()) {
+                for (auto &elem : p->getList()) {
+                    // 需要扩展到tuple末端：创建新的tuple并追加
+                    py::list tmp = py::list(pyTuple);
+                    tmp.append(elem->toPythonObject());
+                    pyTuple = py::tuple(tmp);
+                }
+            } else if (p->isPythonObject()) {
+                try {
+                    py::object pyObj = p->toPythonObject();
+                    if (py::isinstance<py::iterable>(pyObj)) {
+                        for (auto item : pyObj) {
+                            py::list tmp = py::list(pyTuple);
+                            tmp.append(item);
+                            pyTuple = py::tuple(tmp);
+                        }
+                    } else {
+                        py::list tmp = py::list(pyTuple);
+                        tmp.append(pyObj);
+                        pyTuple = py::tuple(tmp);
+                    }
+                } catch (...) {
+                    reportError("Failed to expand *args", ctx);
+                    return any();
+                }
+            } else {
+                py::list tmp = py::list(pyTuple);
+                tmp.append(p->toPythonObject());
+                pyTuple = py::tuple(tmp);
+            }
+        }
+
+        // 构建kwargs
+        py::dict pyKwargs;
+        for (auto &kv : keywords) {
+            pyKwargs[kv.first.c_str()] = kv.second->toPythonObject();
+        }
+        // 处理 **kwargs 展开
+        for (auto &p : starKw) {
+            if (p->isDictionary()) {
+                for (auto &kv : p->getDictionary()) {
+                    pyKwargs[kv.first.c_str()] = kv.second->toPythonObject();
+                }
+            } else if (p->isPythonObject()) {
+                try {
+                    py::object pyObj = p->toPythonObject();
+                    if (py::isinstance<py::dict>(pyObj)) {
+                        py::dict pyD = pyObj.cast<py::dict>();
+                        for (auto item : pyD) {
+                            std::string key = py::str(item.first).cast<std::string>();
+                            pyKwargs[key.c_str()] = item.second;
+                        }
+                    } else {
+                        reportError("** unpack requires a mapping", ctx);
+                        return any();
+                    }
+                } catch (...) {
+                    reportError("Failed to expand **kwargs", ctx);
+                    return any();
+                }
+            } else {
+                reportError("** unpack requires a mapping", ctx);
+                return any();
+            }
+        }
+
+        // 使用DynamicPythonCaller来调用函数以传递args和kwargs
+        py::object result = DynamicPythonCaller::callFunction(pyFunc, py::args(pyTuple), py::kwargs(pyKwargs));
+        logger_.debug(std::string("Result type=") + py::str(py::type::of(result)).cast<std::string>() 
+                  + ", result=" + py::str(result).cast<std::string>());
+        return any(ScriptValue::fromPythonObject(result));
+    } catch (const py::error_already_set& e) {
+        logger_.error(std::string("Python error=") + e.what());
+        reportError("Python function call error: " + string(e.what()), ctx);
+        return any();
+    } catch (const exception& e) {
+        logger_.error(std::string("Exception=") + e.what());
+        reportError("Function call error: " + string(e.what()), ctx);
+        return any();
+    } 
+}
+
+any AstVisitor::visitAttributeAccess(PyScriptParser::AttributeAccessContext *ctx) {
+    logger_.debug("visitAttributeAccess called");
+    
+    auto primaryCtx = ctx->primaryExpression();
+    if (!primaryCtx) {
+        reportError("Attribute access missing object", ctx);
+        return any();
+    }
+    
+    auto objectAny = this->visit(primaryCtx);
+    shared_ptr<ScriptValue> objectValue;
+    try {
+        objectValue = any_cast<shared_ptr<ScriptValue>>(objectAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate object in attribute access", ctx);
+        return any();
+    }
+    
+    if (!objectValue) {
+        reportError("Cannot evaluate object in attribute access", ctx);
+        return any();
+    }
+    
+    string memberName = ctx->IDENTIFIER()->getText();
+    logger_.debug(std::string("Member name: ") + memberName);
+
+    auto member = python_bridge_.getMember(objectValue, memberName);
+    if (!member) {
+        reportError("Object has no member: " + memberName, ctx);
+        return any();
+    }
+
+    logger_.debug(std::string("Member type=") + std::to_string(static_cast<int>(member->getType())) + ", value=" + member->toString());
+    
+    return any(member);
+}
+
+any AstVisitor::visitSubscriptAccess(PyScriptParser::SubscriptAccessContext *ctx) {
+    logger_.debug("visitSubscriptAccess called");
+    
+    auto primaryCtx = ctx->primaryExpression();
+    if (!primaryCtx) {
+        reportError("Subscript access missing object", ctx);
+        return any();
+    }
+    
+    auto objectAny = visit(primaryCtx);
+    shared_ptr<ScriptValue> objectValue;
+    try {
+        objectValue = any_cast<shared_ptr<ScriptValue>>(objectAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate object in subscript access", ctx);
+        return any();
+    }
+    
+    if (!objectValue) {
+        reportError("Cannot evaluate object in subscript access", ctx);
+        return any();
+    }
+    
+    auto indexValue = evaluateExpression(ctx->expression());
+    if (!indexValue) {
+        reportError("Cannot evaluate subscript index", ctx);
+        return any();
+    }
+    
+    if (objectValue->isPythonObject()) {
+        py::object pyObj = objectValue->getPythonObject();
+        
+        // 检查是否是函数对象，函数对象不可下标
+        if (py::isinstance<py::function>(pyObj)) {
+            reportError("Cannot use function object as subscriptable", ctx);
+            return any();
+        }
+        
+        try {
+            py::object pyIndex = indexValue->toPythonObject();
+            py::object result = pyObj[pyIndex];
+            return any(ScriptValue::fromPythonObject(result));
+        } catch (const py::error_already_set& e) {
+            reportError("Python subscript error: " + string(e.what()), ctx);
+            return any();
+        }
+    } else if (objectValue->isList()) {
+        auto& list = objectValue->getList();
+        
+        // 索引必须是整数
+        if (!indexValue->isInteger()) {
+            reportError("List index must be an integer", ctx);
+            return any();
+        }
+        
+        long long index = indexValue->getInteger();
+        
+        if (index < 0 || index >= static_cast<long long>(list.size())) {
+            reportError("List index out of bounds: " + to_string(index) + 
+                       " (list size: " + to_string(list.size()) + ")", ctx);
+            return any();
+        }
+        
+        return any(list[index]);
+    } else if (objectValue->isDictionary()) {
+        auto& dict = objectValue->getDictionary();
+        
+        // 索引必须是字符串
+        if (!indexValue->isString()) {
+            reportError("Dictionary key must be a string", ctx);
+            return any();
+        }
+        
+        string key = indexValue->getString();
+        
+        auto it = dict.find(key);
+        if (it == dict.end()) {
+            reportError("Dictionary key not found: " + key, ctx);
+            return any();
+        }
+        
+        return any(it->second);
+    } else {
+        reportError("Subscript not supported for this type", ctx);
+        return any();
+    }
+}
+
+any AstVisitor::visitPrimaryExpression(PyScriptParser::PrimaryExpressionContext *ctx) {
+    if (ctx->literal()) {
+        return visit(ctx->literal());
+    } else if (ctx->dottedName()) {
+        return visit(ctx->dottedName());
+    } else if (ctx->expression()) {
+        auto value = evaluateExpression(ctx->expression());
+        return any(value);
+    } else if (ctx->listLiteral()) {
+        return visit(ctx->listLiteral());
+    } else if (ctx->dictLiteral()) {
+        return visit(ctx->dictLiteral());
+    } else if (ctx->newExpression()) {
+        return visit(ctx->newExpression());
+    } else if (ctx->lambdaExpression()) {
+        return visit(ctx->lambdaExpression());
+    } else if (ctx->listComprehension()) {
+        return visit(ctx->listComprehension());
+    }
+    
+    reportError("Invalid primary expression", ctx);
+    return any();
+}
+
+any AstVisitor::visitNewExpression(PyScriptParser::NewExpressionContext *ctx) {
+    logger_.debug("visitNewExpression called");
+    
+    auto dottedNameCtx = ctx->dottedName();
+    if (!dottedNameCtx) {
+        reportError("New expression must specify a class name", ctx);
+        return any();
+    }
+    
+    // 收集参数（支持位置参数、关键字参数以及 * / ** 展开）
+    vector<shared_ptr<ScriptValue>> positional;
+    unordered_map<string, shared_ptr<ScriptValue>> keywords;
+    vector<shared_ptr<ScriptValue>> starPos;
+    vector<shared_ptr<ScriptValue>> starKw;
+
+    if (ctx->argumentList()) {
+        auto argCtxs = ctx->argumentList()->argument();
+        logger_.debug(std::string("Argument count: ") + std::to_string(argCtxs.size()));
+        for (size_t i = 0; i < argCtxs.size(); ++i) {
+            auto a = argCtxs[i];
+            if (a->IDENTIFIER() && a->ASSIGN()) {
+                auto val = evaluateExpression(a->expression());
+                if (!val) { reportError("Cannot evaluate keyword argument", ctx); return any(); }
+                keywords[a->IDENTIFIER()->getText()] = val;
+            } else if (a->MUL()) {
+                auto val = evaluateExpression(a->expression());
+                if (!val) { reportError("Cannot evaluate * argument", ctx); return any(); }
+                starPos.push_back(val);
+            } else if (a->DOUBLE_STAR()) {
+                auto val = evaluateExpression(a->expression());
+                if (!val) { reportError("Cannot evaluate ** argument", ctx); return any(); }
+                starKw.push_back(val);
+            } else if (a->expression()) {
+                auto val = evaluateExpression(a->expression());
+                positional.push_back(val ? val : ScriptValue::createNull());
+            } else {
+                reportError("Invalid argument", ctx);
+                return any();
+            }
+        }
+    }
+
+    // 构建py::tuple
+    py::tuple pyTuple(positional.size());
+    size_t idx = 0;
+    for (auto &p : positional) {
+        pyTuple[idx++] = p->toPythonObject();
+    }
+    for (auto &p : starPos) {
+        if (p->isList()) {
+            for (auto &elem : p->getList()) {
+                py::list tmp = py::list(pyTuple);
+                tmp.append(elem->toPythonObject());
+                pyTuple = py::tuple(tmp);
+            }
+        } else if (p->isPythonObject()) {
+            try {
+                py::object pyObj = p->toPythonObject();
+                if (py::isinstance<py::iterable>(pyObj)) {
+                    for (auto item : pyObj) {
+                        py::list tmp = py::list(pyTuple);
+                        tmp.append(item);
+                        pyTuple = py::tuple(tmp);
+                    }
+                } else {
+                    py::list tmp = py::list(pyTuple);
+                    tmp.append(pyObj);
+                    pyTuple = py::tuple(tmp);
+                }
+            } catch (...) {
+                reportError("Failed to expand *args", ctx);
+                return any();
+            }
+        } else {
+            py::list tmp = py::list(pyTuple);
+            tmp.append(p->toPythonObject());
+            pyTuple = py::tuple(tmp);
+        }
+    }
+
+    // 构建kwargs
+    py::dict pyKwargs;
+    for (auto &kv : keywords) {
+        pyKwargs[kv.first.c_str()] = kv.second->toPythonObject();
+    }
+    for (auto &p : starKw) {
+        if (p->isDictionary()) {
+            for (auto &kv : p->getDictionary()) {
+                pyKwargs[kv.first.c_str()] = kv.second->toPythonObject();
+            }
+        } else if (p->isPythonObject()) {
+            try {
+                py::object pyObj = p->toPythonObject();
+                if (py::isinstance<py::dict>(pyObj)) {
+                    py::dict pyD = pyObj.cast<py::dict>();
+                    for (auto item : pyD) {
+                        std::string key = py::str(item.first).cast<std::string>();
+                        pyKwargs[key.c_str()] = item.second;
+                    }
+                } else {
+                    reportError("** unpack requires a mapping", ctx);
+                    return any();
+                }
+            } catch (...) {
+                reportError("Failed to expand **kwargs", ctx);
+                return any();
+            }
+        } else {
+            reportError("** unpack requires a mapping", ctx);
+            return any();
+        }
+    }
+    
+    string className = dottedNameCtx->getText();
+    logger_.debug(std::string("Class name: ") + className);
+    
+    // 将点分名称拆分为部分
+    vector<string> parts;
+    size_t start = 0;
+    size_t dotPos;
+    while ((dotPos = className.find('.', start)) != string::npos) {
+        parts.push_back(className.substr(start, dotPos - start));
+        start = dotPos + 1;
+    }
+    parts.push_back(className.substr(start));
+    
+    if (parts.empty()) {
+        reportError("Empty class name", ctx);
+        return any();
+    }
+    
+    // 获取基础对象（第一个部分）
+    string firstPart = parts[0];
+    shared_ptr<ScriptValue> currentValue = getVariable(firstPart);
+    if (!currentValue) {
+        // 检查是否是导入的模块
+        auto module = variable_manager_.getModule(firstPart);
+        if (module) {
+            currentValue = ScriptValue::createPythonObject(module);
+        } else {
+            // 不是变量也不是已导入的模块，尝试作为模块导入
+            try {
+                py::module_ module = py::module_::import(firstPart.c_str());
+                variable_manager_.importModule(firstPart, module);
+                currentValue = ScriptValue::createPythonObject(module);
+            } catch (const py::error_already_set& e) {
+                reportError("Failed to import module " + firstPart + 
+                           ": " + string(e.what()), ctx);
+                return any();
+            }
+        }
+    }
+    
+    // 逐级获取属性（除了最后一部分）
+    for (size_t i = 1; i < parts.size() - 1; ++i) {
+        currentValue = python_bridge_.getMember(currentValue, parts[i]);
+        if (!currentValue) {
+            reportError("Cannot get member '" + parts[i] + "' in " + className, ctx);
+            return any();
+        }
+    }
+    
+    // 获取类对象（最后一部分）
+    string lastPart = parts.back();
+    shared_ptr<ScriptValue> classValue;
+    if (parts.size() == 1) {
+        // 只有一部分，当前值就是类对象
+        classValue = currentValue;
+    } else {
+        classValue = python_bridge_.getMember(currentValue, lastPart);
+        if (!classValue) {
+            reportError("Cannot get class '" + lastPart + "' in " + className, ctx);
+            return any();
+        }
+    }
+    
+    if (!classValue->isPythonObject()) {
+        reportError("Cannot instantiate non-class type", ctx);
+        return any();
+    }
+    
+    try {
+        py::object pyClass = classValue->getPythonObject();
+        py::object instance = DynamicPythonCaller::callFunction(pyClass, py::args(pyTuple), py::kwargs(pyKwargs));
+        return any(ScriptValue::fromPythonObject(instance));
+    } catch (const py::error_already_set& e) {
+        reportError("Failed to create instance " + className + 
+                   ": " + string(e.what()), ctx);
+        return any();
+    } catch (const exception& e) {
+        reportError("Instance creation error: " + string(e.what()), ctx);
+        return any();
+    }
+}
+
+any AstVisitor::visitLiteral(PyScriptParser::LiteralContext *ctx) {
+    if (ctx->INTEGER()) {
+        long long value = stoll(ctx->INTEGER()->getText());
+        return any(ScriptValue::createInteger(value));
+    } else if (ctx->FLOAT()) {
+        double value = stod(ctx->FLOAT()->getText());
+        return any(ScriptValue::createDouble(value));
+    } else if (ctx->STRING()) {
+        string text = ctx->STRING()->getText();
+        // 去掉引号
+        if (text.length() >= 2) {
+            text = text.substr(1, text.length() - 2);
+        }
+        return any(ScriptValue::createString(text));
+    } else if (ctx->BOOL()) {
+        bool value = (ctx->BOOL()->getText() == "true");
+        return any(ScriptValue::createBoolean(value));
+    } else if (ctx->NULL_LIT()) {
+        return any(ScriptValue::createNull());
+    }
+    
+    reportError("Invalid literal", ctx);
+    return any();
+}
+
+any AstVisitor::visitListLiteral(PyScriptParser::ListLiteralContext *ctx) {
+    logger_.debug("visitListLiteral called");
+    auto listVal = ScriptValue::createList();
+    
+    if (ctx->expressionList()) {
+        // 使用增强的visitExpressionList方法获取表达式值向量
+        auto exprListResult = visitExpressionList(ctx->expressionList());
+        try {
+            auto values = any_cast<vector<shared_ptr<ScriptValue>>>(exprListResult);
+            for (const auto& value : values) {
+                listVal->append(value);
+                logger_.debug(std::string("List element added: type=") + 
+                            std::to_string(static_cast<int>(value->getType())) + 
+                            ", value=" + value->toString());
+            }
+        } catch (const bad_any_cast&) {
+            // 如果类型转换失败，回退到旧的方法
+            logger_.debug("Failed to get expression list values, falling back to old method");
+            auto exprList = ctx->expressionList()->expression();
+            for (auto expr : exprList) {
+                auto value = evaluateExpression(expr);
+                if (value) {
+                    listVal->append(value);
+                } else {
+                    reportError("Cannot evaluate list element", ctx);
+                    return any();
+                }
+            }
+        }
+    }
+    
+    logger_.debug(std::string("Created list with ") + std::to_string(listVal->listSize()) + " elements");
+    return any(listVal);
+}
+
+any AstVisitor::visitDictLiteral(PyScriptParser::DictLiteralContext *ctx) {
+    logger_.debug("visitDictLiteral called");
+    auto dictVal = ScriptValue::createDictionary();
+    
+    if (ctx->dictItemList()) {
+        // 使用增强的visitDictItemList方法获取字典项向量
+        auto dictItemListResult = visitDictItemList(ctx->dictItemList());
+        try {
+            auto items = any_cast<vector<pair<shared_ptr<ScriptValue>, shared_ptr<ScriptValue>>>>(dictItemListResult);
+            for (const auto& item : items) {
+                if (item.first) {
+                    string keyStr = item.first->toString();
+                    dictVal->setKey(keyStr, item.second);
+                    logger_.debug(std::string("Dict item added: key=") + keyStr + 
+                                ", value type=" + std::to_string(static_cast<int>(item.second->getType())));
+                } else {
+                    // 展开项：合并字典或Python映射
+                    auto unpackValue = item.second;
+                    if (!unpackValue) {
+                        reportError("Cannot evaluate dictionary unpack expression", ctx);
+                        return any();
+                    }
+
+                    if (unpackValue->isPythonObject()) {
+                        try {
+                            py::object pyObj = unpackValue->getPythonObject();
+                            py::module_ builtins = py::module_::import("builtins");
+                            py::object dictType = builtins.attr("dict");
+                            if (py::isinstance(pyObj, dictType)) {
+                                py::dict pyDict = pyObj.cast<py::dict>();
+                                for (auto item : pyDict) {
+                                    py::object key = py::reinterpret_borrow<py::object>(item.first);
+                                    py::object value = py::reinterpret_borrow<py::object>(item.second);
+                                    string keyStr = key.cast<string>();
+                                    auto val = ScriptValue::fromPythonObject(value);
+                                    dictVal->setKey(keyStr, val);
+                                }
+                            } else {
+                                reportError("Cannot unpack non-dictionary object", ctx);
+                                return any();
+                            }
+                        } catch (const py::error_already_set& e) {
+                            reportError("Dictionary unpack error: " + string(e.what()), ctx);
+                            return any();
+                        }
+                    } else if (unpackValue->isDictionary()) {
+                        auto& unpackDict = unpackValue->getDictionary();
+                        for (auto& kv : unpackDict) {
+                            dictVal->setKey(kv.first, kv.second);
+                        }
+                    } else {
+                        reportError("Cannot unpack non-dictionary object", ctx);
+                        return any();
+                    }
+                }
+            }
+        } catch (const bad_any_cast&) {
+            // 如果类型转换失败，回退到旧的方法
+            logger_.debug("Failed to get dict item list values, falling back to old method");
+            auto items = ctx->dictItemList()->dictItem();
+            for (auto item : items) {
+                // 使用 dynamic_cast 来检查具体的类型
+                auto* kv = dynamic_cast<PyScriptParser::KeyValuePairContext*>(item);
+                auto* unpack = dynamic_cast<PyScriptParser::DictUnpackContext*>(item);
+                
+                if (kv) {
+                    auto keyValue = evaluateExpression(kv->expression(0));
+                    auto valValue = evaluateExpression(kv->expression(1));
+                    
+                    if (!keyValue || !valValue) {
+                        reportError("Cannot evaluate dictionary key-value pair", ctx);
+                        return any();
+                    }
+                    
+                    string keyStr = keyValue->toString();
+                    dictVal->setKey(keyStr, valValue);
+                } else if (unpack) {
+                    // 字典展开：**expression
+                    auto unpackExpr = unpack->expression();
+                    auto unpackValue = evaluateExpression(unpackExpr);
+                    
+                    if (!unpackValue) {
+                        reportError("Cannot evaluate dictionary unpack expression", ctx);
+                        return any();
+                    }
+                    
+                    // 如果展开的值是字典，合并到当前字典
+                    if (unpackValue->isPythonObject()) {
+                        try {
+                            py::object pyObj = unpackValue->getPythonObject();
+                            // 检查是否是字典
+                            py::module_ builtins = py::module_::import("builtins");
+                            py::object dictType = builtins.attr("dict");
+                            
+                            if (py::isinstance(pyObj, dictType)) {
+                                // 合并字典
+                                py::dict pyDict = pyObj.cast<py::dict>();
+                                for (auto item : pyDict) {
+                                    py::object key = py::reinterpret_borrow<py::object>(item.first);
+                                    py::object value = py::reinterpret_borrow<py::object>(item.second);
+                                    string keyStr = key.cast<string>();
+                                    auto val = ScriptValue::fromPythonObject(value);
+                                    dictVal->setKey(keyStr, val);
+                                }
+                            } else {
+                                reportError("Cannot unpack non-dictionary object", ctx);
+                                return any();
+                            }
+                        } catch (const py::error_already_set& e) {
+                            reportError("Dictionary unpack error: " + string(e.what()), ctx);
+                            return any();
+                        }
+                    } else if (unpackValue->isDictionary()) {
+                        // 如果是ScriptValue字典，直接合并
+                        auto& unpackDict = unpackValue->getDictionary();
+                        for (auto& kv : unpackDict) {
+                            dictVal->setKey(kv.first, kv.second);
+                        }
+                    } else {
+                        reportError("Cannot unpack non-dictionary object", ctx);
+                        return any();
+                    }
+                } else {
+                    reportError("Unknown dictionary item type", ctx);
+                    return any();
+                }
+            }
+        }
+    }
+    
+    logger_.debug(std::string("Created dictionary with ") + std::to_string(dictVal->getDictionary().size()) + " entries");
+    return any(dictVal);
+}
+
+any AstVisitor::visitDottedName(PyScriptParser::DottedNameContext *ctx) {
+    // 点分隔的名称可能表示一个模块、模块的属性，或者一个变量
+    string name = ctx->getText();
+    logger_.debug(std::string("visitDottedName: ") + name);
+    
+    // 如果正在定义函数，则返回一个占位符，不报错
+    if (defining_function_) {
+        logger_.debug(std::string("Defining function, returning placeholder for: ") + name);
+        // 返回一个null值作为占位符
+        return any(ScriptValue::createNull());
+    }
+    
+    // 首先检查变量
+    auto var = variable_manager_.getVariable(name);
+    if (var) {
+        logger_.debug("Found in variables");
+        return any(var);
+    }
+    
+    // 检查导入的模块
+    auto module = variable_manager_.getModule(name);
+    if (module) {
+        logger_.debug("Found in imported_modules");
+        return any(ScriptValue::createPythonObject(module));
+    }
+    
+    // 检查是否为内置Python对象
+    if (name == "True" || name == "true") {
+        return any(ScriptValue::createBoolean(true));
+    } else if (name == "False" || name == "false") {
+        return any(ScriptValue::createBoolean(false));
+    } else if (name == "None" || name == "none" || name == "null") {
+        return any(ScriptValue::createNull());
+    }
+    
+    // 检查是否为Python内置函数
+    auto builtins = variable_manager_.getBuiltins();
+    if (!builtins.is_none()) {
+        try {
+            if (py::hasattr(builtins, name.c_str())) {
+                py::object builtin_func = builtins.attr(name.c_str());
+                return any(ScriptValue::fromPythonObject(builtin_func));
+            }
+        } catch (const py::error_already_set&) {
+            // 忽略错误，继续向下
+        }
+    }
+    
+    // 尝试解析点分隔的名称：可能是模块的属性
+    // 例如 os.path -> 先获取os模块，然后获取path属性
+    vector<string> parts;
+    size_t start = 0;
+    size_t dotPos;
+    while ((dotPos = name.find('.', start)) != string::npos) {
+        parts.push_back(name.substr(start, dotPos - start));
+        start = dotPos + 1;
+    }
+    parts.push_back(name.substr(start));
+    
+    if (parts.size() > 1) {
+        // 尝试获取第一个部分作为模块或变量
+        string firstPart = parts[0];
+        auto firstVar = variable_manager_.getVariable(firstPart);
+        if (firstVar) {
+            // 如果第一个部分是Python对象，直接使用py::attr链访问
+            if (firstVar->isPythonObject()) {
+                py::object current = firstVar->getPythonObject();
+                try {
+                    for (size_t i = 1; i < parts.size(); ++i) {
+                        current = current.attr(parts[i].c_str());
+                    }
+                    try {
+                        logger_.debug(std::string("Dotted resolved to python object: ") + py::str(current).cast<std::string>() );
+                    } catch (...) {
+                        logger_.debug("Dotted resolved to python object (no str available)");
+                    }
+                    return any(ScriptValue::fromPythonObject(current));
+                } catch (const py::error_already_set&) {
+                    // 属性不存在，继续向下
+                }
+            } else {
+                // 否则以ScriptValue链式获取成员（支持字典等）
+                std::shared_ptr<ScriptValue> currentValue = firstVar;
+                bool failed = false;
+                for (size_t i = 1; i < parts.size(); ++i) {
+                    currentValue = python_bridge_.getMember(currentValue, parts[i]);
+                    if (!currentValue) {
+                        failed = true;
+                        break;
+                    }
+                }
+                if (!failed && currentValue) {
+                    return any(currentValue);
+                }
+            }
+        } else {
+            // 如果不是变量，则检查是否是已导入的模块
+            auto module = variable_manager_.getModule(firstPart);
+            if (module) {
+                py::object current = module;
+                try {
+                    for (size_t i = 1; i < parts.size(); ++i) {
+                        current = current.attr(parts[i].c_str());
+                    }
+                    try {
+                        logger_.debug(std::string("Dotted resolved to module object: ") + py::str(current).cast<std::string>() );
+                    } catch (...) {
+                        logger_.debug("Dotted resolved to module object (no str available)");
+                    }
+                    return any(ScriptValue::fromPythonObject(current));
+                } catch (const py::error_already_set&) {
+                    // 属性不存在，继续向下
+                }
+            } else {
+                // 不是变量也不是已导入模块，尝试导入第一个部分作为模块
+                try {
+                    py::module_ module = py::module_::import(firstPart.c_str());
+                    variable_manager_.importModule(firstPart, module);
+                    py::object current = module;
+                    for (size_t i = 1; i < parts.size(); ++i) {
+                        current = current.attr(parts[i].c_str());
+                    }
+                    return any(ScriptValue::fromPythonObject(current));
+                } catch (const py::error_already_set&) {
+                    // 失败，继续后续解析
+                }
+            }
+        }
+    }
+    
+    reportError("Undefined identifier: " + name, ctx);
+    return any();
+}
+
+any AstVisitor::visitArgumentList(PyScriptParser::ArgumentListContext *ctx) {
+    logger_.debug("visitArgumentList called");
+    
+    vector<shared_ptr<ScriptValue>> args;
+    if (ctx) {
+        auto arguments = ctx->argument();
+        logger_.debug(std::string("Number of arguments: ") + std::to_string(arguments.size()));
+        for (size_t i = 0; i < arguments.size(); ++i) {
+            auto argCtx = arguments[i];
+            if (argCtx->IDENTIFIER() && argCtx->ASSIGN()) {
+                // keyword arg - handled at call sites
+                logger_.debug(std::string("Keyword argument detected: ") + argCtx->IDENTIFIER()->getText());
+                continue;
+            } else if (argCtx->MUL() || argCtx->DOUBLE_STAR()) {
+                // star/unpack - handled at call sites
+                logger_.debug("Star/unpack argument detected");
+                continue;
+            } else if (argCtx->expression()) {
+                auto argValue = evaluateExpression(argCtx->expression());
+                if (argValue) {
+                    args.push_back(argValue);
+                    logger_.debug(std::string("Arg[") + std::to_string(i) + "] type=" + std::to_string(static_cast<int>(argValue->getType())) + ", value=" + argValue->toString());
+                } else {
+                    reportError("Cannot evaluate argument", ctx);
+                    return any();
+                }
+            } else {
+                reportError("Invalid argument", ctx);
+                return any();
+            }
+        }
+    }
+    return any(args);
+} 
+
+any AstVisitor::visitExpressionList(PyScriptParser::ExpressionListContext *ctx) {
+    logger_.debug("visitExpressionList called");
+    
+    vector<shared_ptr<ScriptValue>> values;
+    if (ctx) {
+        auto expressions = ctx->expression();
+        logger_.debug(std::string("Number of expressions: ") + std::to_string(expressions.size()));
+        for (size_t i = 0; i < expressions.size(); ++i) {
+            auto exprValue = evaluateExpression(expressions[i]);
+            if (exprValue) {
+                values.push_back(exprValue);
+                logger_.debug(std::string("Expression[") + std::to_string(i) + "] type=" + 
+                            std::to_string(static_cast<int>(exprValue->getType())) + 
+                            ", value=" + exprValue->toString());
+            } else {
+                reportError("Cannot evaluate expression in expression list", ctx);
+                return any();
+            }
+        }
+    }
+    return any(values);
+}
+
+any AstVisitor::visitDictItemList(PyScriptParser::DictItemListContext *ctx) {
+    logger_.debug("visitDictItemList called");
+    
+    vector<pair<shared_ptr<ScriptValue>, shared_ptr<ScriptValue>>> items;
+    if (ctx) {
+        auto dictItems = ctx->dictItem();
+        logger_.debug(std::string("Number of dict items: ") + std::to_string(dictItems.size()));
+        for (size_t i = 0; i < dictItems.size(); ++i) {
+            auto itemResult = visit(dictItems[i]);
+            // 首先尝试读取为键值对
+            try {
+                auto itemPair = any_cast<pair<shared_ptr<ScriptValue>, shared_ptr<ScriptValue>>>(itemResult);
+                items.push_back(itemPair);
+                logger_.debug(std::string("DictItem[") + std::to_string(i) + "] kv added");
+                continue;
+            } catch (const bad_any_cast&) {
+                // 不是键值对，尝试判断是否为展开标记（单个ScriptValue）
+            }
+
+            try {
+                auto unpackVal = any_cast<shared_ptr<ScriptValue>>(itemResult);
+                // 表示这是一个展开项：用一个空的key来表示展开（first==nullptr）
+                items.push_back(make_pair(shared_ptr<ScriptValue>(nullptr), unpackVal));
+                logger_.debug(std::string("DictItem[") + std::to_string(i) + "] unpack added");
+                continue;
+            } catch (const bad_any_cast&) {
+                // 都不是，报错
+                reportError("Invalid dictionary item", ctx);
+                return any();
+            }
+        }
+    }
+    return any(items);
+}
+
+// 新增：参数/Argument 和 power 表达式的基础实现
+any AstVisitor::visitArgument(PyScriptParser::ArgumentContext *ctx) {
+    logger_.debug("visitArgument called");
+    // 具体的解析在调用时完成，这里作为占位实现
+    return any();
+}
+
+any AstVisitor::visitParameter(PyScriptParser::ParameterContext *ctx) {
+    logger_.debug("visitParameter called");
+    // 参数解析在函数定义阶段处理，这里保持占位
+    return any();
+}
+
+any AstVisitor::visitPowerExpression(PyScriptParser::PowerExpressionContext *ctx) {
+    logger_.debug("visitPowerExpression called");
+    if (!ctx->unaryExpression()) {
+        reportError("Invalid power expression", ctx);
+        return any();
+    }
+    auto leftAny = visit(ctx->unaryExpression());
+    shared_ptr<ScriptValue> left;
+    try {
+        left = any_cast<shared_ptr<ScriptValue>>(leftAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate left-hand side of power expression", ctx);
+        return any();
+    }
+    if (!left) {
+        reportError("Cannot evaluate left-hand side of power expression", ctx);
+        return any();
+    }
+    if (!ctx->DOUBLE_STAR()) {
+        return any(left);
+    }
+
+    // 右侧是另一个powerExpression（右结合）
+    auto rightAny = visit(ctx->powerExpression());
+    shared_ptr<ScriptValue> right;
+    try {
+        right = any_cast<shared_ptr<ScriptValue>>(rightAny);
+    } catch (const bad_any_cast&) {
+        reportError("Cannot evaluate right-hand side of power expression", ctx);
+        return any();
+    }
+
+    if (!right) {
+        reportError("Cannot evaluate right-hand side of power expression", ctx);
+        return any();
+    }
+
+    try {
+        if (left->isInteger() && right->isInteger()) {
+            long long base = left->getInteger();
+            long long exp = right->getInteger();
+            if (exp < 0) {
+                double r = std::pow((double)base, (double)exp);
+                return any(ScriptValue::createDouble(r));
+            }
+            long long res = 1;
+            for (long long i = 0; i < exp; ++i) res *= base;
+            return any(ScriptValue::createInteger(res));
+        } else {
+            double r = std::pow(left->toDouble(), right->toDouble());
+            return any(ScriptValue::createDouble(r));
+        }
+    } catch (const exception& e) {
+        reportError(std::string("Power operation error: ") + e.what(), ctx);
+        return any();
+    }
+} 
+
+any AstVisitor::visitKeyValuePair(PyScriptParser::KeyValuePairContext *ctx) {
+    logger_.debug("visitKeyValuePair called");
+    
+    if (!ctx || ctx->expression().size() < 2) {
+        reportError("Invalid key-value pair", ctx);
+        return any();
+    }
+    
+    auto keyExpr = ctx->expression(0);
+    auto valueExpr = ctx->expression(1);
+    
+    auto keyValue = evaluateExpression(keyExpr);
+    auto valueValue = evaluateExpression(valueExpr);
+    
+    if (!keyValue || !valueValue) {
+        reportError("Cannot evaluate key-value pair", ctx);
+        return any();
+    }
+    
+    logger_.debug(std::string("Key: type=") + std::to_string(static_cast<int>(keyValue->getType())) + 
+                ", value=" + keyValue->toString());
+    logger_.debug(std::string("Value: type=") + std::to_string(static_cast<int>(valueValue->getType())) + 
+                ", value=" + valueValue->toString());
+    
+    return any(make_pair(keyValue, valueValue));
+}
+
+any AstVisitor::visitDictUnpack(PyScriptParser::DictUnpackContext *ctx) {
+    logger_.debug("visitDictUnpack called");
+    
+    if (!ctx || !ctx->expression()) {
+        reportError("Invalid dictionary unpack", ctx);
+        return any();
+    }
+    
+    auto expr = ctx->expression();
+    auto unpackValue = evaluateExpression(expr);
+    
+    if (!unpackValue) {
+        reportError("Cannot evaluate dictionary unpack expression", ctx);
+        return any();
+    }
+    
+    // 返回一个特殊的标记，表示这是一个字典展开操作
+    // 在visitDictLiteral中会处理这个标记
+    return any(unpackValue);
+}
+
+any AstVisitor::visitLambdaExpression(PyScriptParser::LambdaExpressionContext *ctx) {
+    logger_.debug("visitLambdaExpression called");
+    
+    // 获取表达式文本
+    auto exprCtx = ctx->expression();
+    if (!exprCtx) {
+        reportError("Lambda expression must have a body", ctx);
+        return any();
+    }
+    
+    std::string exprText = exprCtx->getText();
+    logger_.debug(std::string("Lambda expression body: ") + exprText);
+    
+    // 获取参数列表
+    std::vector<std::string> paramNames;
+    auto identifiers = ctx->IDENTIFIER();
+    for (auto* id : identifiers) {
+        paramNames.push_back(id->getText());
+    }
+    
+    // 构建Python lambda字符串
+    std::string lambdaStr = "lambda ";
+    if (!paramNames.empty()) {
+        for (size_t i = 0; i < paramNames.size(); ++i) {
+            if (i > 0) lambdaStr += ", ";
+            lambdaStr += paramNames[i];
+        }
+    }
+    lambdaStr += ": ";
+    lambdaStr += exprText;
+    
+    logger_.debug(std::string("Python lambda string: ") + lambdaStr);
+    
+    // 捕获当前变量环境
+    py::dict locals;
+    auto varNames = variable_manager_.getAllVariableNames();
+    for (const auto& varName : varNames) {
+        auto var = variable_manager_.getVariable(varName);
+        if (var) {
+            try {
+                locals[py::str(varName)] = var->toPythonObject();
+            } catch (const std::exception& e) {
+                std::cerr << "Warning: Failed to convert variable '" << varName << "' to Python object: " << e.what() << std::endl;
+            }
+        }
+    }
+    
+    // 确保globals包含必要的内置函数
+    py::dict globals = py::globals();
+    if (!globals.contains("__builtins__")) {
+        try {
+            py::module_ builtins = py::module_::import("builtins");
+            globals["__builtins__"] = builtins;
+        } catch (...) {
+            // 忽略错误
+        }
+    }
+    
+    // 使用Python的eval创建lambda函数
+    try {
+        py::object builtins = py::module_::import("builtins");
+        py::object lambdaFunc = builtins.attr("eval")(lambdaStr, globals, locals);
+        logger_.debug("Lambda function created successfully");
+        return any(ScriptValue::fromPythonObject(lambdaFunc));
+    } catch (const py::error_already_set& e) {
+        logger_.error(std::string("Python eval error: ") + e.what());
+        reportError("Failed to create lambda function: " + std::string(e.what()), ctx);
+        return any();
+    } catch (const std::exception& e) {
+        logger_.error(std::string("General error: ") + e.what());
+        reportError("Failed to create lambda function: " + std::string(e.what()), ctx);
+        return any();
+    }
+}
+
+any AstVisitor::visitForStatement(PyScriptParser::ForStatementContext *ctx) {
+    logger_.debug("visitForStatement called");
+
+    auto forControlCtx = ctx->forControl();
+    if (!forControlCtx) {
+        reportError("For statement missing control", ctx);
+        return any();
+    }
+
+    // 执行初始化部分（如果有）
+    if (forControlCtx->forInit()) {
+        visit(forControlCtx->forInit());
+        if (error_handler_.hasError()) {
+            return any();
+        }
+    }
+
+    // 循环条件
+    auto condExpr = forControlCtx->expression();
+    if (!condExpr) {
+        // 如果没有条件表达式，默认为true（无限循环）
+        // 在实际中应该避免无限循环，但这里简单处理
+    }
+
+    while (true) {
+        if (condExpr) {
+            auto condValue = evaluateExpression(condExpr);
+            if (!condValue) {
+                reportError("Cannot evaluate for loop condition", ctx);
+                break;
+            }
+            if (!expression_evaluator_.isTruthy(condValue)) {
+                break;
+            }
+        }
+
+        // 执行循环体
+        this->visit(ctx->block());
+        if (error_handler_.hasError()) {
+            break;
+        }
+
+        // 执行更新部分（如果有）
+        if (forControlCtx->forUpdate()) {
+            visit(forControlCtx->forUpdate());
+            if (error_handler_.hasError()) {
+                break;
+            }
+        }
+    }
+
+    return any();
+}
+
+any AstVisitor::visitForControl(PyScriptParser::ForControlContext *ctx) {
+    // for控制已经在visitForStatement中处理
+    return any();
+}
+
+any AstVisitor::visitForInit(PyScriptParser::ForInitContext *ctx) {
+    // 执行初始化赋值
+    if (ctx->assignment()) {
+        return visit(ctx->assignment());
+    }
+    return any();
+}
+
+any AstVisitor::visitForUpdate(PyScriptParser::ForUpdateContext *ctx) {
+    // 执行更新赋值
+    if (ctx->assignment()) {
+        return visit(ctx->assignment());
+    }
+    return any();
+}
+
+any AstVisitor::visitListComprehension(PyScriptParser::ListComprehensionContext *ctx) {
+    logger_.debug("visitListComprehension called");
+    
+    auto expr = ctx->expression(0);  // 表达式部分
+    auto varName = ctx->IDENTIFIER();
+    auto iterableExpr = ctx->expression(1);  // 可迭代对象
+    
+    if (!expr || !varName || !iterableExpr) {
+        reportError("Invalid list comprehension syntax", ctx);
+        return any();
+    }
+    
+    // 获取可迭代对象的值
+    auto iterableValue = evaluateExpression(iterableExpr);
+    if (!iterableValue) {
+        reportError("Cannot evaluate iterable in list comprehension", ctx);
+        return any();
+    }
+    
+    // 构建Python列表推导式字符串
+    std::string compStr = "[";
+    compStr += expr->getText();
+    compStr += " for ";
+    compStr += varName->getText();
+    compStr += " in ";
+    compStr += iterableExpr->getText();
+    compStr += "]";
+    
+    logger_.debug(std::string("Python list comprehension string: ") + compStr);
+    
+    // 捕获当前变量环境
+    py::dict locals;
+    auto varNames = variable_manager_.getAllVariableNames();
+    for (const auto& varName : varNames) {
+        auto var = variable_manager_.getVariable(varName);
+        if (var) {
+            try {
+                locals[py::str(varName)] = var->toPythonObject();
+            } catch (const std::exception& e) {
+                std::cerr << "Warning: Failed to convert variable '" << varName << "' to Python object: " << e.what() << std::endl;
+            }
+        }
+    }
+    
+    // 确保globals包含必要的内置函数
+    py::dict globals = py::globals();
+    if (!globals.contains("__builtins__")) {
+        try {
+            py::module_ builtins = py::module_::import("builtins");
+            globals["__builtins__"] = builtins;
+        } catch (...) {
+            // 忽略错误
+        }
+    }
+    
+    // 使用Python的eval创建列表
+    try {
+        py::object builtins = py::module_::import("builtins");
+        py::object resultList = builtins.attr("eval")(compStr, globals, locals);
+        logger_.debug("List comprehension created successfully");
+        return any(ScriptValue::fromPythonObject(resultList));
+    } catch (const py::error_already_set& e) {
+        std::cerr << "Python eval error: " << e.what() << std::endl;
+        reportError("Failed to create list comprehension: " + std::string(e.what()), ctx);
+        return any();
+    } catch (const std::exception& e) {
+        std::cerr << "General error: " << e.what() << std::endl;
+        reportError("Failed to create list comprehension: " + std::string(e.what()), ctx);
+        return any();
+    }
+}
+
+any AstVisitor::visitAttributeAccessOp(PyScriptParser::AttributeAccessOpContext *ctx) {
+    logger_.debug("visitAttributeAccessOp called");
+    
+    // 获取当前对象值（来自callOrPrimary中的primaryExpression）
+    // 注意：attributeAccessOp的父节点是postfixOp，postfixOp的父节点是callOrPrimary
+    // 我们需要获取到当前的对象值，这应该通过上下文传递，这里简化处理
+    // 实际实现中，callOrPrimary应该累积应用postfixOp
+    
+    // 临时实现：报告错误
+    reportError("Attribute access operator not fully implemented yet", ctx);
+    return any();
+}
+
+any AstVisitor::visitSubscriptAccessOp(PyScriptParser::SubscriptAccessOpContext *ctx) {
+    logger_.debug("visitSubscriptAccessOp called");
+    
+    // 临时实现：报告错误
+    reportError("Subscript access operator not fully implemented yet", ctx);
+    return any();
+}
+
+any AstVisitor::visitFunctionCallOp(PyScriptParser::FunctionCallOpContext *ctx) {
+    logger_.debug("visitFunctionCallOp called");
+    
+    // 临时实现：报告错误
+    reportError("Function call operator not fully implemented yet", ctx);
+    return any();
+}
diff --git a/src/dynamic_python_caller.cpp b/src/dynamic_python_caller.cpp
index 59a174a..14c7025 100644
--- a/src/dynamic_python_caller.cpp
+++ b/src/dynamic_python_caller.cpp
@@ -1,6 +1,9 @@
 #include "dynamic_python_caller.h"
 #include <iostream>
 
+// Static logger for static helper methods
+static Logger s_logger;
+
 DynamicPythonCaller::DynamicPythonCaller(const std::string& moduleName, const std::string& functionName)
     : moduleName_(moduleName), functionName_(functionName) {
     if (!moduleName.empty() && !functionName.empty()) {
@@ -27,7 +30,7 @@ void DynamicPythonCaller::importAndGetFunction() {
         py::module_ module = py::module_::import(moduleName_.c_str());
         function_ = module.attr(functionName_.c_str());
     } catch (const py::error_already_set& e) {
-        std::cerr << "Error importing module/function: " << moduleName_ << "." << functionName_ << std::endl;
+        logger_.error(std::string("Error importing module/function: ") + moduleName_ + "." + functionName_);
         function_ = py::none();
     }
 }
@@ -208,7 +211,7 @@ std::vector<std::string> DynamicPythonCaller::listModuleFunctions(const std::str
         std::sort(functions.begin(), functions.end());
         
     } catch (const py::error_already_set& e) {
-        std::cerr << "Error listing module functions: " << e.what() << std::endl;
+        s_logger.error(std::string("Error listing module functions: ") + e.what());
     }
     
     return functions;
@@ -244,7 +247,7 @@ std::map<std::string, py::object> DynamicPythonCaller::getModuleFunctionMap(cons
         }
         
     } catch (const py::error_already_set& e) {
-        std::cerr << "Error getting module function map: " << e.what() << std::endl;
+        s_logger.error(std::string("Error getting module function map: ") + e.what());
     }
     
     return functionMap;
@@ -309,7 +312,7 @@ std::map<std::string, std::any> DynamicPythonCaller::getModuleInfo(const std::st
         }
         
     } catch (const py::error_already_set& e) {
-        std::cerr << "Error getting module info: " << e.what() << std::endl;
+        s_logger.error(std::string("Error getting module info: ") + e.what());
     }
     
     return info;
@@ -436,7 +439,7 @@ std::vector<std::string> DynamicPythonCaller::listModuleClasses(const std::strin
         std::sort(classes.begin(), classes.end());
         
     } catch (const py::error_already_set& e) {
-        std::cerr << "Error listing module classes: " << e.what() << std::endl;
+        s_logger.error(std::string("Error listing module classes: ") + e.what());
     }
     
     return classes;
@@ -472,7 +475,7 @@ std::map<std::string, py::object> DynamicPythonCaller::getModuleClassMap(const s
         }
         
     } catch (const py::error_already_set& e) {
-        std::cerr << "Error getting module class map: " << e.what() << std::endl;
+        s_logger.error(std::string("Error getting module class map: ") + e.what());
     }
     
     return classMap;
@@ -729,7 +732,7 @@ std::vector<std::string> DynamicPythonCaller::getClassMembers(py::object classOb
         std::sort(members.begin(), members.end());
         
     } catch (const py::error_already_set& e) {
-        std::cerr << "Error getting class members: " << e.what() << std::endl;
+        s_logger.error(std::string("Error getting class members: ") + e.what());
     }
     
     return members;
@@ -745,7 +748,7 @@ std::vector<std::string> DynamicPythonCaller::getClassMethods(const std::string&
         return getClassMembers(classObj, "methods", includeInherited);
         
     } catch (const py::error_already_set& e) {
-        std::cerr << "Error getting class methods: " << e.what() << std::endl;
+        s_logger.error(std::string("Error getting class methods: ") + e.what());
         return {};
     }
 }
@@ -760,7 +763,7 @@ std::vector<std::string> DynamicPythonCaller::getClassAttributes(const std::stri
         return getClassMembers(classObj, "attributes", includeInherited);
         
     } catch (const py::error_already_set& e) {
-        std::cerr << "Error getting class attributes: " << e.what() << std::endl;
+        s_logger.error(std::string("Error getting class attributes: ") + e.what());
         return {};
     }
 }
diff --git a/src/python_bridge.cpp b/src/python_bridge.cpp
new file mode 100644
index 0000000..0a9a721
--- /dev/null
+++ b/src/python_bridge.cpp
@@ -0,0 +1,245 @@
+/**
+ * @file python_bridge.cpp
+ * @brief Python桥接模块实现
+ */
+
+#include "python_bridge.h"
+#include "script_value.h"
+#include "logger.h"
+#include <atomic>
+#include <iostream>
+#include <pybind11/eval.h>
+
+namespace script_interpreter {
+
+PythonBridge::PythonBridge() {
+    configurePythonPath();
+}
+
+PythonBridge::~PythonBridge() {
+    // 不做任何事，解释器由外部管理
+}
+
+void PythonBridge::configurePythonPath() {
+    try {
+        py::module_ sys = py::module_::import("sys");
+        // 将当前目录下的python目录添加到Python路径
+        py::str python_path = "../python";
+        sys.attr("path").attr("insert")(0, python_path);
+        std::cout << "[PythonBridge] Python path configured: " << python_path.cast<std::string>() << std::endl;
+    } catch (const std::exception& e) {
+        std::cerr << "[PythonBridge] Failed to configure Python path: " << e.what() << std::endl;
+    }
+}
+
+std::shared_ptr<ScriptValue> PythonBridge::callPythonFunction(
+    py::object func,
+    const std::vector<std::shared_ptr<ScriptValue>>& args) {
+    
+    try {
+        py::tuple pyArgs(args.size());
+        for (size_t i = 0; i < args.size(); ++i) {
+            pyArgs[i] = args[i]->toPythonObject();
+        }
+        
+        py::object result = func(*pyArgs);
+        return ScriptValue::fromPythonObject(result);
+        
+    } catch (const py::error_already_set& e) {
+        throw std::runtime_error("Python function call error: " + std::string(e.what()));
+    }
+}
+
+std::shared_ptr<ScriptValue> PythonBridge::createPythonInstance(
+    const std::string& moduleName,
+    const std::string& className,
+    const std::vector<std::shared_ptr<ScriptValue>>& args) {
+    
+    try {
+        py::module_ module = py::module_::import(moduleName.c_str());
+        py::object classObj = module.attr(className.c_str());
+        
+        py::tuple pyArgs(args.size());
+        for (size_t i = 0; i < args.size(); ++i) {
+            pyArgs[i] = args[i]->toPythonObject();
+        }
+        
+        py::object instance = classObj(*pyArgs);
+        return ScriptValue::fromPythonObject(instance);
+        
+    } catch (const py::error_already_set& e) {
+        throw std::runtime_error("Python instance creation error: " + std::string(e.what()));
+    }
+}
+
+std::shared_ptr<ScriptValue> PythonBridge::getMember(
+    std::shared_ptr<ScriptValue> object,
+    const std::string& memberName) {
+    
+    if (!object) {
+        return nullptr;
+    }
+    
+    if (object->isPythonObject()) {
+        py::object pyObj = object->getPythonObject();
+        
+        // 特殊处理 toString 方法
+        if (memberName == "toString" || memberName == "toString()") {
+            // 对于Python对象，返回一个调用 str(obj) 的 lambda 函数
+            try {
+                py::object str_func = py::module_::import("builtins").attr("str");
+                py::object lambda_func = py::cpp_function([pyObj, str_func]() {
+                    return str_func(pyObj);
+                });
+                return ScriptValue::fromPythonObject(lambda_func);
+            } catch (const py::error_already_set& e) {
+                std::cerr << "[PythonBridge] Error creating toString lambda: " << e.what() << std::endl;
+                return nullptr;
+            }
+        }
+        
+        try {
+            if (py::isinstance<py::module_>(pyObj)) {
+                py::module_ module = pyObj.cast<py::module_>();
+                py::object member = module.attr(memberName.c_str());
+                return ScriptValue::fromPythonObject(member);
+            } else if (py::hasattr(pyObj, memberName.c_str())) {
+                py::object member = pyObj.attr(memberName.c_str());
+                return ScriptValue::fromPythonObject(member);
+            }
+        } catch (const py::error_already_set&) {
+            // 属性不存在，检查是否是Python内置方法
+            // 对于Python对象，检查是否有__str__、__repr__等方法
+            if (memberName == "__str__" || memberName == "__repr__") {
+                try {
+                    py::object member = pyObj.attr(memberName.c_str());
+                    return ScriptValue::fromPythonObject(member);
+                } catch (const py::error_already_set&) {
+                    // 方法不存在
+                }
+            }
+        }
+    }
+
+    // 支持字典对象成员访问
+    if (object->isDictionary()) {
+        try {
+            if (object->hasKey(memberName)) {
+                return object->getKey(memberName);
+            }
+            return nullptr;
+        } catch (const std::exception& e) {
+            std::cerr << "[PythonBridge] Error accessing dictionary member: " << e.what() << std::endl;
+            return nullptr;
+        }
+    }
+    
+    // 对于非Python对象，也可以支持toString方法
+    if (memberName == "toString" || memberName == "toString()") {
+        // 返回一个返回对象字符串表示的lambda
+        try {
+            py::object str_func = py::module_::import("builtins").attr("str");
+            py::object obj_py = object->toPythonObject();
+            py::object lambda_func = py::cpp_function([obj_py, str_func]() {
+                return str_func(obj_py);
+            });
+            return ScriptValue::fromPythonObject(lambda_func);
+        } catch (const py::error_already_set& e) {
+            std::cerr << "[PythonBridge] Error creating toString lambda for non-Python object: " << e.what() << std::endl;
+            return nullptr;
+        }
+    }
+    
+    return nullptr;
+}
+
+void PythonBridge::setMember(
+    std::shared_ptr<ScriptValue> object,
+    const std::string& memberName,
+    std::shared_ptr<ScriptValue> value) {
+    
+    if (!object || !object->isPythonObject()) {
+        throw std::runtime_error("Cannot set member on non-object type");
+    }
+    
+    py::object pyObj = object->getPythonObject();
+    py::object pyValue = value->toPythonObject();
+    
+    try {
+        pyObj.attr(memberName.c_str()) = pyValue;
+    } catch (const py::error_already_set& e) {
+        throw std::runtime_error("Python attribute assignment error: " + std::string(e.what()));
+    }
+}
+
+py::module_ PythonBridge::importModule(const std::string& moduleName) {
+    return py::module_::import(moduleName.c_str());
+}
+
+py::object PythonBridge::eval(const std::string& code, 
+                            py::dict globals,
+                            py::dict locals) {
+    return ::pybind11::eval(code, globals, locals);
+}
+
+void PythonBridge::exec(const std::string& code,
+                      py::dict globals,
+                      py::dict locals) {
+    ::pybind11::exec(code, globals, locals);
+}
+
+py::dict PythonBridge::globals() const {
+    return py::globals();
+}
+
+bool PythonBridge::isDict(py::object obj) const {
+    py::module_ builtins = py::module_::import("builtins");
+    py::object dictType = builtins.attr("dict");
+    return py::isinstance(obj, dictType);
+}
+
+bool PythonBridge::isFunction(py::object obj) const {
+    return py::isinstance<py::function>(obj);
+}
+
+bool PythonBridge::isModule(py::object obj) const {
+    return py::isinstance<py::module_>(obj);
+}
+
+bool PythonBridge::hasAttr(py::object obj, const std::string& attrName) const {
+    return py::hasattr(obj, attrName.c_str());
+}
+
+py::object PythonBridge::getAttr(py::object obj, const std::string& attrName) const {
+    return obj.attr(attrName.c_str());
+}
+
+void PythonBridge::setAttr(py::object obj, const std::string& attrName, py::object value) {
+    obj.attr(attrName.c_str()) = value;
+}
+
+std::string PythonBridge::str(py::object obj) const {
+    return py::str(obj).cast<std::string>();
+}
+
+std::string PythonBridge::typeName(py::object obj) const {
+    return py::str(py::type::of(obj)).cast<std::string>();
+}
+
+bool PythonBridge::isCallable(py::object obj) const {
+    return py::hasattr(obj, "__call__");
+}
+
+py::object PythonBridge::getBuiltin(const std::string& name) const {
+    try {
+        py::module_ builtins = py::module_::import("builtins");
+        if (py::hasattr(builtins, name.c_str())) {
+            return builtins.attr(name.c_str());
+        }
+    } catch (...) {
+        // 忽略错误
+    }
+    return py::object();
+}
+
+} // namespace script_interpreter
diff --git a/src/script_interpreter.cpp b/src/script_interpreter.cpp
index 3474c70..15e3000 100644
--- a/src/script_interpreter.cpp
+++ b/src/script_interpreter.cpp
@@ -10,104 +10,85 @@
 using namespace antlr4;
 using namespace std;
 
+using namespace script_interpreter;
+
 // 构造函数
-ScriptInterpreter::ScriptInterpreter() 
-    : result_(nullptr), 
-      has_error_(false), 
-      python_initialized_(false),
-      defining_function_(false) {
-    
-    std::cerr << "ScriptInterpreter constructor started" << std::endl;
-    // 检查Python解释器是否已初始化
-    if (!Py_IsInitialized()) {
-        try {
-            py::initialize_interpreter();
-            python_initialized_ = true;
-            std::cerr << "Python interpreter initialized" << std::endl;
-        } catch (const exception& e) {
-            cerr << "Failed to initialize Python interpreter: " << e.what() << endl;
-        }
-    } else {
-        std::cerr << "Python interpreter already initialized" << std::endl;
-    }
-    
-    // 配置Python路径
-    try {
-        py::module_ sys = py::module_::import("sys");
-        // 将当前目录下的python目录添加到Python路径
-        py::str python_path = "../python";
-        sys.attr("path").attr("insert")(0, python_path);
-        std::cerr << "Python path configured: " << python_path.cast<std::string>() << std::endl;
-    } catch (const exception& e) {
-        cerr << "Failed to configure Python path: " << e.what() << endl;
-    }
+ScriptInterpreter::ScriptInterpreter()
+    : result_(nullptr),
+      defining_function_(false),
+      expression_evaluator_(variable_manager_, error_handler_, logger_, python_bridge_),
+      ast_visitor_(variable_manager_, error_handler_, logger_, python_bridge_, expression_evaluator_) {
+
+    logger_.info("ScriptInterpreter constructor started");
+    // Python桥接器自动初始化Python解释器
+    logger_.debug("PythonBridge initialized");
     
     // 导入builtins模块以供内置函数使用
     try {
-        builtins_ = py::module_::import("builtins");
-        std::cerr << "Builtins imported successfully" << std::endl;
+        py::module_ builtins = py::module_::import("builtins");
+        variable_manager_.setBuiltins(builtins);
+        logger_.info("Builtins imported successfully");
     } catch (const exception& e) {
-        cerr << "Failed to import builtins: " << e.what() << endl;
-        // 将builtins_设置为none，后续使用时再尝试导入
-        builtins_ = py::none();
+        logger_.error(std::string("Failed to import builtins: ") + e.what());
+        // 将builtins设置为none，后续使用时再尝试导入
+        variable_manager_.setBuiltins(py::none());
     }
-    std::cerr << "ScriptInterpreter constructor finished" << std::endl;
+    logger_.debug("ScriptInterpreter constructor finished");
 }
 
 // 析构函数
 ScriptInterpreter::~ScriptInterpreter() {
-    if (python_initialized_) {
-        try {
-            py::finalize_interpreter();
-        } catch (...) {
-            // 忽略清理错误
-        }
+    try {
+        // 清理所有可能持有Python对象的成员，避免在Python解释器已终止后析构时导致崩溃
+        variable_manager_.clearAll();
+        result_.reset();
+    } catch (...) {
+        // 忽略清理错误
     }
 }
 
 // 执行脚本
 bool ScriptInterpreter::execute(const string& script) {
-    std::cerr << "ScriptInterpreter::execute() called with script: " << script << std::endl;
-    has_error_ = false;
-    error_message_.clear();
+    logger_.debug(std::string("ScriptInterpreter::execute() called with script: ") + script);
+    error_handler_.clearErrors();
     result_ = nullptr;
     
     try {
-        std::cerr << "Creating ANTLRInputStream..." << std::endl;
+        logger_.debug("Creating ANTLRInputStream...");
         ANTLRInputStream input(script);
-        std::cerr << "Creating PyScriptLexer..." << std::endl;
+        logger_.debug("Creating PyScriptLexer...");
         PyScriptLexer lexer(&input);
-        std::cerr << "Creating CommonTokenStream..." << std::endl;
+        logger_.debug("Creating CommonTokenStream...");
         CommonTokenStream tokens(&lexer);
         
         // 填充token流
-        std::cerr << "Filling tokens..." << std::endl;
+        logger_.debug("Filling tokens...");
         tokens.fill();
         
-        std::cerr << "Creating PyScriptParser..." << std::endl;
+        logger_.debug("Creating PyScriptParser...");
         PyScriptParser parser(&tokens);
         
         // 设置错误处理器
         parser.removeErrorListeners();
         
-        std::cerr << "Parsing program..." << std::endl;
+        logger_.debug("Parsing program...");
         auto tree = parser.program();
-        std::cerr << "Parse tree created successfully" << std::endl;
+        logger_.debug("Parse tree created successfully");
         
-        if (has_error_) {
-            std::cerr << "Has error before visiting" << std::endl;
+        if (error_handler_.hasError()) {
+            logger_.warn("Has error before visiting");
             return false;
         }
         
         // 遍历AST
-        std::cerr << "Visiting program tree..." << std::endl;
+        logger_.debug("Visiting program tree...");
         visitProgram(tree);
-        std::cerr << "Visit completed" << std::endl;
+        logger_.debug("Visit completed");
         
-        return !has_error_;
+        return !error_handler_.hasError();
         
     } catch (const exception& e) {
-        std::cerr << "Exception in execute: " << e.what() << std::endl;
+        logger_.error(std::string("Exception in execute: ") + e.what());
         reportError("Script execution error: " + string(e.what()));
         return false;
     }
@@ -128,55 +109,54 @@ bool ScriptInterpreter::executeFile(const string& filename) {
 }
 
 shared_ptr<ScriptValue> ScriptInterpreter::getVariable(const string& name) {
-    auto it = variables_.find(name);
-    if (it != variables_.end()) {
-        return it->second;
-    }
-    return nullptr;
+    return variable_manager_.getVariable(name);
 }
 
 void ScriptInterpreter::setVariable(const string& name, shared_ptr<ScriptValue> value) {
-    variables_[name] = value;
+    variable_manager_.setVariable(name, value);
 }
 
 void ScriptInterpreter::clearEnvironment() {
-    variables_.clear();
-    // imported_modules_.clear(); // 保留导入的模块，避免重复导入
+    variable_manager_.clearVariables();
     result_ = nullptr;
-    has_error_ = false;
-    error_message_.clear();
+    error_handler_.clearErrors();
 }
 
-// ========== 错误报告 ==========
+// ========== 错误报告 ===========
 
-void ScriptInterpreter::reportError(const string& message) {
-    error_message_ = message;
-    has_error_ = true;
-    cerr << "Script Error: " << message << endl;
+void ScriptInterpreter::reportError(const std::string& message,
+                                    ScriptErrorType type,
+                                    ScriptErrorCode code,
+                                    int line, int column) {
+    error_handler_.reportError(message, type, code, line, column);
+    logger_.error(std::string("Script Error: ") + message + " [Type=" + to_string(static_cast<int>(type))
+              + ", Code=" + to_string(static_cast<int>(code)) + ", Line=" + to_string(line) + ", Col=" + to_string(column) + "]");
 }
 
-void ScriptInterpreter::reportError(const string& message, antlr4::ParserRuleContext *ctx) {
-    string fullMessage = message;
-    
+void ScriptInterpreter::reportError(const std::string& message, antlr4::ParserRuleContext *ctx,
+                                    ScriptErrorType type,
+                                    ScriptErrorCode code) {
+    int line = -1, column = -1;
     if (ctx) {
         auto token = ctx->getStart();
         if (token) {
-            fullMessage += " at line " + to_string(token->getLine()) +
-                          ", column " + to_string(token->getCharPositionInLine());
+            line = token->getLine();
+            column = token->getCharPositionInLine();
         }
     }
-    
-    reportError(fullMessage);
+    error_handler_.reportError(message, type, code, line, column);
+    logger_.error(std::string("Script Error: ") + message + " [Type=" + to_string(static_cast<int>(type))
+              + ", Code=" + to_string(static_cast<int>(code)) + ", Line=" + to_string(line) + ", Col=" + to_string(column) + "]");
 }
 
 // ========== 辅助方法 ==========
 
 shared_ptr<ScriptValue> ScriptInterpreter::evaluateExpression(PyScriptParser::ExpressionContext *ctx) {
     if (!ctx) {
-        std::cerr << "evaluateExpression: ctx is null!" << std::endl;
+        logger_.error("evaluateExpression: ctx is null!");
         return nullptr;
     }
-    auto result = visit(ctx);
+    auto result = ast_visitor_.visit(ctx);
     try {
         return any_cast<shared_ptr<ScriptValue>>(result);
     } catch (const bad_any_cast&) {
@@ -184,301 +164,11 @@ shared_ptr<ScriptValue> ScriptInterpreter::evaluateExpression(PyScriptParser::Ex
     }
 }
 
-shared_ptr<ScriptValue> ScriptInterpreter::evaluateBinaryOperation(
-    const string& op,
-    shared_ptr<ScriptValue> left,
-    shared_ptr<ScriptValue> right) {
-    
-    try {
-        if (op == "+") {
-            // 数字相加或字符串连接
-            if (left->isInteger() && right->isInteger()) {
-                return ScriptValue::createInteger(left->getInteger() + right->getInteger());
-            } else if (left->isNumber() && right->isNumber()) {
-                return ScriptValue::createDouble(left->toDouble() + right->toDouble());
-            } else if (left->isString() || right->isString()) {
-                return ScriptValue::createString(left->toString() + right->toString());
-            } else if (left->isList() && right->isList()) {
-                // 列表合并
-                auto leftList = left->getList();
-                auto rightList = right->getList();
-                vector<shared_ptr<ScriptValue>> newList;
-                newList.reserve(leftList.size() + rightList.size());
-                newList.insert(newList.end(), leftList.begin(), leftList.end());
-                newList.insert(newList.end(), rightList.begin(), rightList.end());
-                return std::make_shared<ScriptValue>(newList);
-            } else if (left->isPythonObject() || right->isPythonObject()) {
-                py::object result = left->toPythonObject() + right->toPythonObject();
-                return ScriptValue::fromPythonObject(result);
-            }
-        } else if (op == "-") {
-            if (left->isNumber() && right->isNumber()) {
-                if (left->isInteger() && right->isInteger()) {
-                    return ScriptValue::createInteger(left->getInteger() - right->getInteger());
-                } else {
-                    return ScriptValue::createDouble(left->toDouble() - right->toDouble());
-                }
-            } else if (left->isPythonObject() || right->isPythonObject()) {
-                py::object result = left->toPythonObject() - right->toPythonObject();
-                return ScriptValue::fromPythonObject(result);
-            }
-        } else if (op == "*") {
-            if (left->isNumber() && right->isNumber()) {
-                if (left->isInteger() && right->isInteger()) {
-                    return ScriptValue::createInteger(left->getInteger() * right->getInteger());
-                } else {
-                    return ScriptValue::createDouble(left->toDouble() * right->toDouble());
-                }
-            } else if (left->isPythonObject() || right->isPythonObject()) {
-                py::object result = left->toPythonObject() * right->toPythonObject();
-                return ScriptValue::fromPythonObject(result);
-            }
-        } else if (op == "/") {
-            if (left->isNumber() && right->isNumber()) {
-                double divisor = right->toDouble();
-                if (abs(divisor) < 1e-10) {
-                    throw runtime_error("Division by zero");
-                }
-                return ScriptValue::createDouble(left->toDouble() / divisor);
-            } else if (left->isPythonObject() || right->isPythonObject()) {
-                py::object result = left->toPythonObject() / right->toPythonObject();
-                return ScriptValue::fromPythonObject(result);
-            }
-        } else if (op == "%") {
-            if (left->isInteger() && right->isInteger()) {
-                long long divisor = right->getInteger();
-                if (divisor == 0) {
-                    throw runtime_error("Modulo by zero");
-                }
-                return ScriptValue::createInteger(left->getInteger() % divisor);
-            } else {
-                throw runtime_error("Modulo operation requires integer operands");
-            }
-        } else if (op == "==") {
-            bool equal = (*left == *right);
-            return ScriptValue::createBoolean(equal);
-        } else if (op == "!=") {
-            bool notEqual = !(*left == *right);
-            return ScriptValue::createBoolean(notEqual);
-        } else if (op == "<") {
-            if (left->isNumber() && right->isNumber()) {
-                return ScriptValue::createBoolean(left->toDouble() < right->toDouble());
-            } else if (left->isPythonObject() || right->isPythonObject()) {
-                py::object lhs = left->toPythonObject();
-                py::object rhs = right->toPythonObject();
-                py::object result = py::reinterpret_steal<py::object>(PyObject_RichCompare(lhs.ptr(), rhs.ptr(), Py_LT));
-                if (!result.ptr() || result.is_none()) {
-                    throw py::error_already_set();
-                }
-                return ScriptValue::fromPythonObject(result);
-            }
-        } else if (op == ">") {
-            if (left->isNumber() && right->isNumber()) {
-                return ScriptValue::createBoolean(left->toDouble() > right->toDouble());
-            } else if (left->isPythonObject() || right->isPythonObject()) {
-                py::object lhs = left->toPythonObject();
-                py::object rhs = right->toPythonObject();
-                py::object result = py::reinterpret_steal<py::object>(PyObject_RichCompare(lhs.ptr(), rhs.ptr(), Py_GT));
-                if (result.is_none()) {
-                    throw py::error_already_set();
-                }
-                return ScriptValue::fromPythonObject(result);
-            }
-        } else if (op == "<=") {
-            if (left->isNumber() && right->isNumber()) {
-                return ScriptValue::createBoolean(left->toDouble() <= right->toDouble());
-            } else if (left->isPythonObject() || right->isPythonObject()) {
-                py::object lhs = left->toPythonObject();
-                py::object rhs = right->toPythonObject();
-                py::object result = py::reinterpret_steal<py::object>(PyObject_RichCompare(lhs.ptr(), rhs.ptr(), Py_LE));
-                if (result.is_none()) {
-                    throw py::error_already_set();
-                }
-                return ScriptValue::fromPythonObject(result);
-            }
-        } else if (op == ">=") {
-            if (left->isNumber() && right->isNumber()) {
-                return ScriptValue::createBoolean(left->toDouble() >= right->toDouble());
-            } else if (left->isPythonObject() || right->isPythonObject()) {
-                py::object lhs = left->toPythonObject();
-                py::object rhs = right->toPythonObject();
-                py::object result = py::reinterpret_steal<py::object>(PyObject_RichCompare(lhs.ptr(), rhs.ptr(), Py_GE));
-                if (result.is_none()) {
-                    throw py::error_already_set();
-                }
-                return ScriptValue::fromPythonObject(result);
-            }
-        } else if (op == "&&") {
-            return ScriptValue::createBoolean(left->toBoolean() && right->toBoolean());
-        } else if (op == "||") {
-            return ScriptValue::createBoolean(left->toBoolean() || right->toBoolean());
-        }
-        
-        throw runtime_error("Unsupported binary operator: " + op);
-        
-    } catch (const exception& e) {
-        throw runtime_error("Binary operation error: " + string(e.what()));
-    }
-}
-
-shared_ptr<ScriptValue> ScriptInterpreter::evaluateUnaryOperation(
-    const string& op,
-    shared_ptr<ScriptValue> value) {
-    
-    try {
-        if (op == "-") {
-            if (value->isInteger()) {
-                return ScriptValue::createInteger(-value->getInteger());
-            } else if (value->isDouble()) {
-                return ScriptValue::createDouble(-value->getDouble());
-            } else if (value->isPythonObject()) {
-                py::object result = -value->getPythonObject();
-                return ScriptValue::fromPythonObject(result);
-            } else {
-                throw runtime_error("Unary - operator not supported for this type");
-            }
-        } else if (op == "!") {
-            return ScriptValue::createBoolean(!value->toBoolean());
-        }
-        
-        throw runtime_error("Unsupported unary operator: " + op);
-        
-    } catch (const exception& e) {
-        throw runtime_error("Unary operation error: " + string(e.what()));
-    }
-}
 
-bool ScriptInterpreter::isTruthy(shared_ptr<ScriptValue> value) const {
-    if (!value) return false;
-    return value->toBoolean();
-}
 
-shared_ptr<ScriptValue> ScriptInterpreter::callPythonFunction(
-    py::object func,
-    const vector<shared_ptr<ScriptValue>>& args) {
-    
-    try {
-        py::tuple pyArgs(args.size());
-        for (size_t i = 0; i < args.size(); ++i) {
-            pyArgs[i] = args[i]->toPythonObject();
-        }
-        
-        py::object result = func(*pyArgs);
-        return ScriptValue::fromPythonObject(result);
-        
-    } catch (const py::error_already_set& e) {
-        throw runtime_error("Python function call error: " + string(e.what()));
-    }
-}
 
-shared_ptr<ScriptValue> ScriptInterpreter::createPythonInstance(
-    const string& moduleName,
-    const string& className,
-    const vector<shared_ptr<ScriptValue>>& args) {
-    
-    try {
-        py::module_ module = py::module_::import(moduleName.c_str());
-        py::object classObj = module.attr(className.c_str());
-        
-        py::tuple pyArgs(args.size());
-        for (size_t i = 0; i < args.size(); ++i) {
-            pyArgs[i] = args[i]->toPythonObject();
-        }
-        
-        py::object instance = classObj(*pyArgs);
-        return ScriptValue::fromPythonObject(instance);
-        
-    } catch (const py::error_already_set& e) {
-        throw runtime_error("Python instance creation error: " + string(e.what()));
-    }
-}
 
-shared_ptr<ScriptValue> ScriptInterpreter::getMember(
-    shared_ptr<ScriptValue> object,
-    const string& memberName) {
-    
-    if (!object) {
-        return nullptr;
-    }
-    
-    if (object->isPythonObject()) {
-        py::object pyObj = object->getPythonObject();
-        
-        // 特殊处理 toString 方法
-        if (memberName == "toString" || memberName == "toString()") {
-            // 对于Python对象，返回一个调用 str(obj) 的 lambda 函数
-            try {
-                py::object str_func = py::module_::import("builtins").attr("str");
-                py::object lambda_func = py::cpp_function([pyObj, str_func]() {
-                    return str_func(pyObj);
-                });
-                return ScriptValue::fromPythonObject(lambda_func);
-            } catch (const py::error_already_set& e) {
-                std::cerr << "Error creating toString lambda: " << e.what() << std::endl;
-                return nullptr;
-            }
-        }
-        
-        try {
-            if (py::isinstance<py::module_>(pyObj)) {
-                py::module_ module = pyObj.cast<py::module_>();
-                py::object member = module.attr(memberName.c_str());
-                return ScriptValue::fromPythonObject(member);
-            } else if (py::hasattr(pyObj, memberName.c_str())) {
-                py::object member = pyObj.attr(memberName.c_str());
-                return ScriptValue::fromPythonObject(member);
-            }
-        } catch (const py::error_already_set&) {
-            // 属性不存在，检查是否是Python内置方法
-            // 对于Python对象，检查是否有__str__、__repr__等方法
-            if (memberName == "__str__" || memberName == "__repr__") {
-                try {
-                    py::object member = pyObj.attr(memberName.c_str());
-                    return ScriptValue::fromPythonObject(member);
-                } catch (const py::error_already_set&) {
-                    // 方法不存在
-                }
-            }
-        }
-    }
-    
-    // 对于非Python对象，也可以支持toString方法
-    if (memberName == "toString" || memberName == "toString()") {
-        // 返回一个返回对象字符串表示的lambda
-        try {
-            py::object str_func = py::module_::import("builtins").attr("str");
-            py::object obj_py = object->toPythonObject();
-            py::object lambda_func = py::cpp_function([obj_py, str_func]() {
-                return str_func(obj_py);
-            });
-            return ScriptValue::fromPythonObject(lambda_func);
-        } catch (const py::error_already_set& e) {
-            std::cerr << "Error creating toString lambda for non-Python object: " << e.what() << std::endl;
-            return nullptr;
-        }
-    }
-    
-    return nullptr;
-}
 
-void ScriptInterpreter::setMember(
-    shared_ptr<ScriptValue> object,
-    const string& memberName,
-    shared_ptr<ScriptValue> value) {
-    
-    if (!object || !object->isPythonObject()) {
-        throw runtime_error("Cannot set member on non-object type");
-    }
-    
-    py::object pyObj = object->getPythonObject();
-    py::object pyValue = value->toPythonObject();
-    
-    try {
-        pyObj.attr(memberName.c_str()) = pyValue;
-    } catch (const py::error_already_set& e) {
-        throw runtime_error("Python attribute assignment error: " + string(e.what()));
-    }
-}
 
 shared_ptr<ScriptValue> ScriptInterpreter::executeBlock(PyScriptParser::BlockContext *ctx) {
     if (!ctx) {
@@ -492,8 +182,8 @@ shared_ptr<ScriptValue> ScriptInterpreter::executeBlock(PyScriptParser::BlockCon
     // 执行代码块中的所有语句
     shared_ptr<ScriptValue> lastResult = nullptr;
     for (auto stmt : ctx->statement()) {
-        auto result = visit(stmt);
-        if (has_error_) {
+        auto result = ast_visitor_.visit(stmt);
+        if (error_handler_.hasError()) {
             break;
         }
         
@@ -512,8 +202,8 @@ shared_ptr<ScriptValue> ScriptInterpreter::executeBlock(PyScriptParser::BlockCon
 any ScriptInterpreter::visitProgram(PyScriptParser::ProgramContext *ctx) {
     // 执行所有语句
     for (auto stmt : ctx->statement()) {
-        visit(stmt);
-        if (has_error_) {
+        ast_visitor_.visit(stmt);
+        if (error_handler_.hasError()) {
             break;
         }
     }
@@ -522,9 +212,8 @@ any ScriptInterpreter::visitProgram(PyScriptParser::ProgramContext *ctx) {
     if (result_ == nullptr && ctx->statement().size() > 0) {
         // 尝试获取最后一个表达式语句的结果
         auto lastStmt = ctx->statement().back();
-        // 注意：这里需要根据实际的statement类型来处理，暂时先简单处理
-        // 实际上应该检查是否是expressionStatement
-        auto exprStmt = dynamic_cast<PyScriptParser::ExpressionStatementContext*>(lastStmt);
+        // 使用ANTLR上下文方法检查是否是expressionStatement
+        auto exprStmt = lastStmt->expressionStatement();
         if (exprStmt) {
             result_ = evaluateExpression(exprStmt->expression());
         }
@@ -536,21 +225,21 @@ any ScriptInterpreter::visitProgram(PyScriptParser::ProgramContext *ctx) {
 any ScriptInterpreter::visitStatement(PyScriptParser::StatementContext *ctx) {
     // 根据实际的子节点类型进行分发
     if (ctx->importStatement()) {
-        return visit(ctx->importStatement());
+        return ast_visitor_.visit(ctx->importStatement());
     } else if (ctx->functionDefinition()) {
-        return visit(ctx->functionDefinition());
+        return ast_visitor_.visit(ctx->functionDefinition());
     } else if (ctx->assignment()) {
-        return visit(ctx->assignment());
+        return ast_visitor_.visit(ctx->assignment());
     } else if (ctx->ifStatement()) {
-        return visit(ctx->ifStatement());
+        return ast_visitor_.visit(ctx->ifStatement());
     } else if (ctx->whileStatement()) {
-        return visit(ctx->whileStatement());
+        return ast_visitor_.visit(ctx->whileStatement());
     } else if (ctx->forStatement()) {
-        return visit(ctx->forStatement());
+        return ast_visitor_.visit(ctx->forStatement());
     } else if (ctx->returnStatement()) {
-        return visit(ctx->returnStatement());
+        return ast_visitor_.visit(ctx->returnStatement());
     } else if (ctx->expressionStatement()) {
-        return visit(ctx->expressionStatement());
+        return ast_visitor_.visit(ctx->expressionStatement());
     }
     
     reportError("Unknown statement type", ctx);
@@ -558,7 +247,7 @@ any ScriptInterpreter::visitStatement(PyScriptParser::StatementContext *ctx) {
 }
 
 any ScriptInterpreter::visitImportStatement(PyScriptParser::ImportStatementContext *ctx) {
-    std::cerr << "visitImportStatement called" << std::endl;
+    logger_.debug("visitImportStatement called");
     
     try {
         auto dottedNameCtx = ctx->dottedName();
@@ -569,51 +258,52 @@ any ScriptInterpreter::visitImportStatement(PyScriptParser::ImportStatementConte
         
         // 获取模块名
         string moduleName = dottedNameCtx->getText();
-        std::cerr << "Importing module: " << moduleName << std::endl;
+        logger_.debug(std::string("Importing module: ") + moduleName);
         
         // 检查是否有别名
         string alias;
         if (ctx->IDENTIFIER()) {
             alias = ctx->IDENTIFIER()->getText();
-            std::cerr << "Alias: " << alias << std::endl;
+            logger_.debug(std::string("Alias: ") + alias);
         }
         
         // 导入Python模块
-        std::cerr << "Calling py::module_::import..." << std::endl;
+        logger_.debug("Calling py::module_::import...");
         py::module_ module = py::module_::import(moduleName.c_str());
-        std::cerr << "Module imported successfully: " << moduleName << std::endl;
+        logger_.info(std::string("Module imported successfully: ") + moduleName);
         
-        imported_modules_[moduleName] = module;
+        // 存储模块到VariableManager
+        variable_manager_.importModule(moduleName, module);
         
-        // 存储模块引用
+        // 存储模块引用到变量
         if (!alias.empty()) {
-            variables_[alias] = ScriptValue::createPythonObject(module);
-            std::cerr << "Module stored in variables with alias: " << alias << std::endl;
+            variable_manager_.setVariable(alias, ScriptValue::createPythonObject(module));
+            logger_.debug(std::string("Module stored in variables with alias: ") + alias);
         } else {
             // 使用模块名的最后一部分作为变量名
             size_t dotPos = moduleName.find_last_of('.');
             string shortName = (dotPos != string::npos) ? 
                               moduleName.substr(dotPos + 1) : moduleName;
-            variables_[shortName] = ScriptValue::createPythonObject(module);
-            std::cerr << "Module stored in variables with short name: " << shortName << std::endl;
+            variable_manager_.setVariable(shortName, ScriptValue::createPythonObject(module));
+            logger_.debug(std::string("Module stored in variables with short name: ") + shortName);
         }
         
         // 验证存储
-        std::cerr << "Verifying storage..." << std::endl;
+        logger_.debug("Verifying storage...");
         if (!alias.empty()) {
-            auto it = variables_.find(alias);
-            if (it != variables_.end()) {
-                std::cerr << "Variable '" << alias << "' found in variables map" << std::endl;
+            auto var = variable_manager_.getVariable(alias);
+            if (var) {
+                logger_.debug(std::string("Variable '") + alias + "' found in variables map");
             } else {
-                std::cerr << "ERROR: Variable '" << alias << "' NOT found in variables map!" << std::endl;
+                logger_.error(std::string("ERROR: Variable '") + alias + "' NOT found in variables map!");
             }
         }
         
     } catch (const py::error_already_set& e) {
-        std::cerr << "Python import error: " << e.what() << std::endl;
+        logger_.error(std::string("Python import error: ") + e.what());
         reportError("Failed to import module: " + string(e.what()), ctx);
     } catch (const exception& e) {
-        std::cerr << "General import error: " << e.what() << std::endl;
+        logger_.error(std::string("General import error: ") + e.what());
         reportError("Import error: " + string(e.what()), ctx);
     }
     
@@ -621,114 +311,8 @@ any ScriptInterpreter::visitImportStatement(PyScriptParser::ImportStatementConte
 }
 
 any ScriptInterpreter::visitFunctionDefinition(PyScriptParser::FunctionDefinitionContext *ctx) {
-    std::cerr << "visitFunctionDefinition called" << std::endl;
-    
-    string funcName = ctx->IDENTIFIER()->getText();
-    std::cerr << "Function name: " << funcName << std::endl;
-    
-    // 获取参数列表
-    vector<string> paramNames;
-    if (ctx->parameterList()) {
-        auto paramIds = ctx->parameterList()->IDENTIFIER();
-        for (auto* id : paramIds) {
-            paramNames.push_back(id->getText());
-        }
-    }
-    
-    // 获取函数体
-    auto blockCtx = ctx->block();
-    if (!blockCtx) {
-        reportError("Function definition missing body", ctx);
-        return any();
-    }
-    
-    // 获取函数体中的所有语句
-    auto statements = blockCtx->statement();
-    std::cerr << "Number of statements in function body: " << statements.size() << std::endl;
-    
-    // 打印语句类型信息
-    for (size_t i = 0; i < statements.size(); ++i) {
-        auto stmt = statements[i];
-        std::cerr << "Statement " << i << " type: " << typeid(*stmt).name() << std::endl;
-        std::cerr << "Statement " << i << " text: " << stmt->getText() << std::endl;
-        
-        // 检查是否是return语句
-        auto returnStmt = dynamic_cast<PyScriptParser::ReturnStatementContext*>(stmt);
-        if (returnStmt) {
-            std::cerr << "Statement " << i << " is a return statement" << std::endl;
-            if (returnStmt->expression()) {
-                std::cerr << "Return expression: " << returnStmt->expression()->getText() << std::endl;
-            }
-        }
-    }
-    
-    // 设置标志防止在函数定义体中报错
-    defining_function_ = true;
-    
-    // 构建函数定义字符串
-    string funcDef = "def " + funcName + "(";
-    for (size_t i = 0; i < paramNames.size(); ++i) {
-        if (i > 0) funcDef += ", ";
-        funcDef += paramNames[i];
-    }
-    funcDef += "):\n";
-    
-    if (statements.empty()) {
-        funcDef += "    pass";
-        std::cerr << "Warning: Function body is empty, using 'pass'" << std::endl;
-    } else {
-    // 遍历所有语句，将它们添加到函数体中
-    for (auto stmt : statements) {
-        // 检查是否是return语句 - 使用StatementContext的方法
-        auto returnStmt = stmt->returnStatement();
-        if (returnStmt) {
-            // 获取return语句中的表达式
-            auto exprCtx = returnStmt->expression();
-            if (exprCtx) {
-                string exprText = exprCtx->getText();
-                funcDef += "    return " + exprText + "\n";
-            } else {
-                funcDef += "    return\n";
-            }
-        } else {
-            // 其他语句，使用原始文本
-            string stmtText = stmt->getText();
-            // 移除末尾的分号（如果有）
-            if (!stmtText.empty() && stmtText.back() == ';') {
-                stmtText.pop_back();
-            }
-            funcDef += "    " + stmtText + "\n";
-        }
-    }
-    }
-    
-    std::cerr << "Function definition string:\n" << funcDef << std::endl;
-    
-    // 在Python中执行函数定义
-    py::dict globals = py::globals();
-    // 确保globals包含__builtins__
-    if (!globals.contains("__builtins__")) {
-        try {
-            py::module_ builtins = py::module_::import("builtins");
-            globals["__builtins__"] = builtins;
-        } catch (...) {
-            // 忽略错误
-        }
-    }
-    
-    try {
-        py::exec(funcDef, globals, globals);
-        py::object func = globals[funcName.c_str()];
-        variables_[funcName] = ScriptValue::fromPythonObject(func);
-        std::cerr << "Function defined: " << funcName << std::endl;
-    } catch (const py::error_already_set& e) {
-        reportError("Failed to define function " + funcName + ": " + string(e.what()), ctx);
-    }
-    
-    // 重置标志
-    defining_function_ = false;
-    // 返回非空值阻止访问子节点
-    return any(true);
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitFunctionDefinition(ctx);
 }
 
 any ScriptInterpreter::visitParameterList(PyScriptParser::ParameterListContext *ctx) {
@@ -737,236 +321,28 @@ any ScriptInterpreter::visitParameterList(PyScriptParser::ParameterListContext *
 }
 
 any ScriptInterpreter::visitIfStatement(PyScriptParser::IfStatementContext *ctx) {
-    std::cerr << "visitIfStatement called" << std::endl;
-    
-    auto exprCtx = ctx->expression();
-    if (!exprCtx) {
-        reportError("If statement condition is missing", ctx);
-        return any();
-    }
-    
-    auto condValue = evaluateExpression(exprCtx);
-    if (!condValue) {
-        reportError("Cannot evaluate condition", ctx);
-        return any();
-    }
-    
-    if (isTruthy(condValue)) {
-        auto thenBlock = ctx->block(0);
-        if (thenBlock) {
-            return visit(thenBlock);
-        }
-    } else if (ctx->block().size() > 1) {
-        auto elseBlock = ctx->block(1);
-        if (elseBlock) {
-            return visit(elseBlock);
-        }
-    }
-    
-    return any();
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitIfStatement(ctx);
 }
 
 any ScriptInterpreter::visitWhileStatement(PyScriptParser::WhileStatementContext *ctx) {
-    while (true) {
-        auto condValue = evaluateExpression(ctx->expression());
-        
-        if (!condValue) {
-            reportError("Cannot evaluate condition", ctx);
-            break;
-        }
-        
-        if (!isTruthy(condValue)) {
-            break;
-        }
-        
-        visit(ctx->block());
-        
-        if (has_error_) {
-            break;
-        }
-    }
-    
-    return any();
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitWhileStatement(ctx);
 }
 
 any ScriptInterpreter::visitReturnStatement(PyScriptParser::ReturnStatementContext *ctx) {
-    // 如果正在定义函数，则跳过求值，只返回占位符
-    if (defining_function_) {
-        std::cerr << "Skipping return statement evaluation during function definition" << std::endl;
-        return any();
-    }
-    
-    if (ctx->expression()) {
-        result_ = evaluateExpression(ctx->expression());
-    } else {
-        result_ = ScriptValue::createNull();
-    }
-    return any();
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitReturnStatement(ctx);
 }
 
 any ScriptInterpreter::visitBlock(PyScriptParser::BlockContext *ctx) {
-    if (ctx->statement().empty()) {
-        // 空代码块
-        return any();
-    }
-    
-    // 执行代码块中的所有语句
-    for (auto stmt : ctx->statement()) {
-        visit(stmt);
-        if (has_error_) {
-            break;
-        }
-    }
-    
-    return any();
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitBlock(ctx);
 }
 
 any ScriptInterpreter::visitAssignment(PyScriptParser::AssignmentContext *ctx) {
-    // 有三种赋值形式：标识符赋值、属性赋值、下标赋值
-    if (ctx->IDENTIFIER()) {
-        // 标识符赋值: IDENTIFIER assignmentOperator expression
-        string varName = ctx->IDENTIFIER()->getText();
-        auto op = ctx->assignmentOperator();
-        if (!op) {
-            reportError("Missing assignment operator", ctx);
-            return any();
-        }
-        
-        auto rightExpr = ctx->expression(); // 右侧表达式
-        if (!rightExpr) {
-            reportError("Missing right-hand side expression", ctx);
-            return any();
-        }
-        
-        auto rightValue = evaluateExpression(rightExpr);
-        if (!rightValue) {
-            reportError("Cannot evaluate right-hand side", ctx);
-            return any();
-        }
-        
-        string opText = op->getText();
-        if (opText == "=") {
-            // 简单赋值
-            variables_[varName] = rightValue;
-        } else {
-            // 复合赋值操作符
-            auto leftVal = getVariable(varName);
-            if (!leftVal) {
-                reportError("Variable '" + varName + "' not defined for compound assignment", ctx);
-                return any();
-            }
-            
-            // 执行复合运算
-            string baseOp = opText.substr(0, opText.size() - 1); // 去掉'='
-            auto result = evaluateBinaryOperation(baseOp, leftVal, rightValue);
-            if (!result) {
-                reportError("Unsupported compound assignment operator: " + opText, ctx);
-                return any();
-            }
-            
-            variables_[varName] = result;
-        }
-    } else if (ctx->attributeAccess()) {
-        // 属性赋值: attributeAccess '=' expression
-        // TODO: 实现属性赋值
-        reportError("Attribute assignment not implemented yet", ctx);
-        return any();
-    } else if (ctx->subscriptAccess()) {
-        // 下标赋值: subscriptAccess '=' expression
-        auto subscriptCtx = ctx->subscriptAccess();
-        auto primaryCtx = subscriptCtx->primaryExpression();
-        if (!primaryCtx) {
-            reportError("Subscript access missing object", ctx);
-            return any();
-        }
-        
-        auto objectAny = visit(primaryCtx);
-        shared_ptr<ScriptValue> objectValue;
-        try {
-            objectValue = any_cast<shared_ptr<ScriptValue>>(objectAny);
-        } catch (const bad_any_cast&) {
-            reportError("Cannot evaluate object in subscript assignment", ctx);
-            return any();
-        }
-        
-        if (!objectValue) {
-            reportError("Cannot evaluate object in subscript assignment", ctx);
-            return any();
-        }
-        
-        auto indexExpr = subscriptCtx->expression();
-        if (!indexExpr) {
-            reportError("Missing subscript index", ctx);
-            return any();
-        }
-        
-        auto indexValue = evaluateExpression(indexExpr);
-        if (!indexValue) {
-            reportError("Cannot evaluate subscript index", ctx);
-            return any();
-        }
-        
-        // 对于下标赋值，直接获取右侧表达式（语法是 subscriptAccess '=' expression）
-        auto rightExpr = ctx->expression(); // 右侧表达式
-        if (!rightExpr) {
-            reportError("Missing right-hand side expression", ctx);
-            return any();
-        }
-        
-        auto rightValue = evaluateExpression(rightExpr);
-        if (!rightValue) {
-            reportError("Cannot evaluate right-hand side", ctx);
-            return any();
-        }
-        
-        // 执行下标赋值
-        if (objectValue->isPythonObject()) {
-            py::object pyObj = objectValue->getPythonObject();
-            try {
-                py::object pyIndex = indexValue->toPythonObject();
-                py::object pyRight = rightValue->toPythonObject();
-                pyObj[pyIndex] = pyRight;
-                // 下标赋值不产生新值，返回右侧值
-                return any(rightValue);
-            } catch (const py::error_already_set& e) {
-                reportError("Python subscript assignment error: " + string(e.what()), ctx);
-                return any();
-            }
-        } else if (objectValue->isList()) {
-            // 列表赋值
-            // 索引必须是整数
-            if (!indexValue->isInteger()) {
-                reportError("List index must be an integer", ctx);
-                return any();
-            }
-            
-            long long index = indexValue->getInteger();
-            
-            if (index < 0 || index >= static_cast<long long>(objectValue->listSize())) {
-                reportError("List index out of bounds: " + to_string(index) + 
-                           " (list size: " + to_string(objectValue->listSize()) + ")", ctx);
-                return any();
-            }
-            
-            // 更新列表元素
-            objectValue->setAt(static_cast<size_t>(index), rightValue);
-            return any(rightValue);
-        } else if (objectValue->isDictionary()) {
-            // 使用ScriptValue的setKey方法
-            if (!indexValue->isString()) {
-                reportError("Dictionary key must be a string", ctx);
-                return any();
-            }
-            string key = indexValue->getString();
-            objectValue->setKey(key, rightValue);
-            return any(rightValue);
-        } else {
-            reportError("Subscript assignment not supported for this type", ctx);
-            return any();
-        }
-    }
-    
-    return any();
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitAssignment(ctx);
 }
 
 any ScriptInterpreter::visitAssignmentOperator(PyScriptParser::AssignmentOperatorContext *ctx) {
@@ -975,21 +351,13 @@ any ScriptInterpreter::visitAssignmentOperator(PyScriptParser::AssignmentOperato
 }
 
 any ScriptInterpreter::visitExpressionStatement(PyScriptParser::ExpressionStatementContext *ctx) {
-    auto value = evaluateExpression(ctx->expression());
-    // 表达式语句的值可以忽略
-    return any(value);
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitExpressionStatement(ctx);
 }
 
 any ScriptInterpreter::visitExpression(PyScriptParser::ExpressionContext *ctx) {
-    // expression: assignment | ternaryExpression
-    if (ctx->assignment()) {
-        return visit(ctx->assignment());
-    } else if (ctx->ternaryExpression()) {
-        return visit(ctx->ternaryExpression());
-    }
-    
-    reportError("Invalid expression", ctx);
-    return any();
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitExpression(ctx);
 }
 
 any ScriptInterpreter::visitTernaryExpression(PyScriptParser::TernaryExpressionContext *ctx) {
@@ -999,7 +367,7 @@ any ScriptInterpreter::visitTernaryExpression(PyScriptParser::TernaryExpressionC
         // 注意：logicalOrExpression() 返回的是 vector，我们需要第一个元素
         auto logicalOrExprs = ctx->logicalOrExpression();
         if (!logicalOrExprs.empty()) {
-            return visit(logicalOrExprs[0]);
+            return ast_visitor_.visit(logicalOrExprs[0]);
         } else {
             reportError("Missing logical or expression in ternary expression", ctx);
             return any();
@@ -1038,8 +406,8 @@ any ScriptInterpreter::visitTernaryExpression(PyScriptParser::TernaryExpressionC
             auto trueExprCtx = logicalOrExprs[0];
             auto condExprCtx = logicalOrExprs[1];
             
-            // 使用visit获取条件值
-            auto condAny = visit(condExprCtx);
+            // 使用ast_visitor_获取条件值
+            auto condAny = ast_visitor_.visit(condExprCtx);
             shared_ptr<ScriptValue> condValue;
             try {
                 condValue = any_cast<shared_ptr<ScriptValue>>(condAny);
@@ -1053,10 +421,10 @@ any ScriptInterpreter::visitTernaryExpression(PyScriptParser::TernaryExpressionC
                 return any();
             }
             
-            if (isTruthy(condValue)) {
-                return visit(trueExprCtx);
+            if (expression_evaluator_.isTruthy(condValue)) {
+                return ast_visitor_.visit(trueExprCtx);
             } else {
-                return visit(falseExpr);
+                return ast_visitor_.visit(falseExpr);
             }
         } else {
             reportError("Invalid Python-style ternary expression", ctx);
@@ -1092,8 +460,8 @@ any ScriptInterpreter::visitTernaryExpression(PyScriptParser::TernaryExpressionC
         }
         
         if (condExprCtx && trueExprCtx && falseExprCtx) {
-            // 使用visit获取条件值
-            auto condAny = visit(condExprCtx);
+            // 使用ast_visitor_获取条件值
+            auto condAny = ast_visitor_.visit(condExprCtx);
             shared_ptr<ScriptValue> condValue;
             try {
                 condValue = any_cast<shared_ptr<ScriptValue>>(condAny);
@@ -1107,10 +475,10 @@ any ScriptInterpreter::visitTernaryExpression(PyScriptParser::TernaryExpressionC
                 return any();
             }
             
-            if (isTruthy(condValue)) {
+            if (expression_evaluator_.isTruthy(condValue)) {
                 return evaluateExpression(trueExprCtx);
             } else {
-                return visit(falseExprCtx);
+                return ast_visitor_.visit(falseExprCtx);
             }
         } else {
             reportError("Invalid C-style ternary expression", ctx);
@@ -1122,13 +490,13 @@ any ScriptInterpreter::visitTernaryExpression(PyScriptParser::TernaryExpressionC
 any ScriptInterpreter::visitLogicalOrExpression(PyScriptParser::LogicalOrExpressionContext *ctx) {
     auto logicalAndExprs = ctx->logicalAndExpression();
     if (logicalAndExprs.size() == 1) {
-        return visit(logicalAndExprs[0]);
+        return ast_visitor_.visit(logicalAndExprs[0]);
     }
     
     // 处理多个逻辑或表达式
     shared_ptr<ScriptValue> result;
     for (auto expr : logicalAndExprs) {
-        auto valAny = visit(expr);
+        auto valAny = ast_visitor_.visit(expr);
         shared_ptr<ScriptValue> val;
         try {
             val = any_cast<shared_ptr<ScriptValue>>(valAny);
@@ -1141,7 +509,7 @@ any ScriptInterpreter::visitLogicalOrExpression(PyScriptParser::LogicalOrExpress
             return any();
         }
         
-        if (isTruthy(val)) {
+        if (expression_evaluator_.isTruthy(val)) {
             result = val;
             break;
         }
@@ -1157,13 +525,13 @@ any ScriptInterpreter::visitLogicalOrExpression(PyScriptParser::LogicalOrExpress
 any ScriptInterpreter::visitLogicalAndExpression(PyScriptParser::LogicalAndExpressionContext *ctx) {
     auto equalityExprs = ctx->equalityExpression();
     if (equalityExprs.size() == 1) {
-        return visit(equalityExprs[0]);
+        return ast_visitor_.visit(equalityExprs[0]);
     }
     
     // 处理多个逻辑与表达式
     shared_ptr<ScriptValue> result;
     for (auto expr : equalityExprs) {
-        auto valAny = visit(expr);
+        auto valAny = ast_visitor_.visit(expr);
         shared_ptr<ScriptValue> val;
         try {
             val = any_cast<shared_ptr<ScriptValue>>(valAny);
@@ -1176,7 +544,7 @@ any ScriptInterpreter::visitLogicalAndExpression(PyScriptParser::LogicalAndExpre
             return any();
         }
         
-        if (!isTruthy(val)) {
+        if (!expression_evaluator_.isTruthy(val)) {
             result = val;
             break;
         }
@@ -1192,7 +560,7 @@ any ScriptInterpreter::visitLogicalAndExpression(PyScriptParser::LogicalAndExpre
 any ScriptInterpreter::visitEqualityExpression(PyScriptParser::EqualityExpressionContext *ctx) {
     auto relationalExprs = ctx->relationalExpression();
     if (relationalExprs.size() == 1) {
-        return visit(relationalExprs[0]);
+        return this->visit(relationalExprs[0]);
     }
     
     // 处理相等性比较
@@ -1225,7 +593,7 @@ any ScriptInterpreter::visitEqualityExpression(PyScriptParser::EqualityExpressio
         
         // 获取操作符
         string op = ctx->children[2*i - 1]->getText();
-        auto result = evaluateBinaryOperation(op, left, right);
+        auto result = expression_evaluator_.evaluateBinaryOperation(op, left, right);
         if (!result) {
             reportError("Unsupported equality operator: " + op, ctx);
             return any();
@@ -1240,7 +608,7 @@ any ScriptInterpreter::visitEqualityExpression(PyScriptParser::EqualityExpressio
 any ScriptInterpreter::visitRelationalExpression(PyScriptParser::RelationalExpressionContext *ctx) {
     auto additiveExprs = ctx->additiveExpression();
     if (additiveExprs.size() == 1) {
-        return visit(additiveExprs[0]);
+        return this->visit(additiveExprs[0]);
     }
     
     // 处理关系比较
@@ -1273,7 +641,7 @@ any ScriptInterpreter::visitRelationalExpression(PyScriptParser::RelationalExpre
         
         // 获取操作符
         string op = ctx->children[2*i - 1]->getText();
-        auto result = evaluateBinaryOperation(op, left, right);
+        auto result = expression_evaluator_.evaluateBinaryOperation(op, left, right);
         if (!result) {
             reportError("Unsupported relational operator: " + op, ctx);
             return any();
@@ -1288,7 +656,7 @@ any ScriptInterpreter::visitRelationalExpression(PyScriptParser::RelationalExpre
 any ScriptInterpreter::visitAdditiveExpression(PyScriptParser::AdditiveExpressionContext *ctx) {
     auto multiplicativeExprs = ctx->multiplicativeExpression();
     if (multiplicativeExprs.size() == 1) {
-        return visit(multiplicativeExprs[0]);
+        return this->visit(multiplicativeExprs[0]);
     }
     
     // 处理加减运算
@@ -1321,9 +689,9 @@ any ScriptInterpreter::visitAdditiveExpression(PyScriptParser::AdditiveExpressio
         
         // 获取操作符
         string op = ctx->children[2*i - 1]->getText();
-        auto result = evaluateBinaryOperation(op, left, right);
+        auto result = expression_evaluator_.evaluateBinaryOperation(op, left, right);
         if (!result) {
-            reportError("Unsupported additive operator: " + op, ctx);
+            reportError("Unsupported multiplicative operator: " + op, ctx);
             return any();
         }
         
@@ -1334,13 +702,13 @@ any ScriptInterpreter::visitAdditiveExpression(PyScriptParser::AdditiveExpressio
 }
 
 any ScriptInterpreter::visitMultiplicativeExpression(PyScriptParser::MultiplicativeExpressionContext *ctx) {
-    auto unaryExprs = ctx->unaryExpression();
-    if (unaryExprs.size() == 1) {
-        return visit(unaryExprs[0]);
+    auto powerExprs = ctx->powerExpression();
+    if (powerExprs.size() == 1) {
+        return this->visit(powerExprs[0]);
     }
     
     // 处理乘除取模运算
-    auto leftAny = visit(unaryExprs[0]);
+    auto leftAny = visit(powerExprs[0]);
     shared_ptr<ScriptValue> left;
     try {
         left = any_cast<shared_ptr<ScriptValue>>(leftAny);
@@ -1353,8 +721,8 @@ any ScriptInterpreter::visitMultiplicativeExpression(PyScriptParser::Multiplicat
         return any();
     }
     
-    for (size_t i = 1; i < unaryExprs.size(); ++i) {
-        auto rightAny = visit(unaryExprs[i]);
+    for (size_t i = 1; i < powerExprs.size(); ++i) {
+        auto rightAny = visit(powerExprs[i]);
         shared_ptr<ScriptValue> right;
         try {
             right = any_cast<shared_ptr<ScriptValue>>(rightAny);
@@ -1369,7 +737,7 @@ any ScriptInterpreter::visitMultiplicativeExpression(PyScriptParser::Multiplicat
         
         // 获取操作符
         string op = ctx->children[2*i - 1]->getText();
-        auto result = evaluateBinaryOperation(op, left, right);
+        auto result = expression_evaluator_.evaluateBinaryOperation(op, left, right);
         if (!result) {
             reportError("Unsupported multiplicative operator: " + op, ctx);
             return any();
@@ -1383,7 +751,7 @@ any ScriptInterpreter::visitMultiplicativeExpression(PyScriptParser::Multiplicat
 
 any ScriptInterpreter::visitUnaryExpression(PyScriptParser::UnaryExpressionContext *ctx) {
     auto callOrPrimaryCtx = ctx->callOrPrimary();
-    auto callOrPrimaryAny = visit(callOrPrimaryCtx);
+    auto callOrPrimaryAny = this->visit(callOrPrimaryCtx);
     shared_ptr<ScriptValue> callOrPrimaryValue;
     try {
         callOrPrimaryValue = any_cast<shared_ptr<ScriptValue>>(callOrPrimaryAny);
@@ -1397,717 +765,68 @@ any ScriptInterpreter::visitUnaryExpression(PyScriptParser::UnaryExpressionConte
         return any();
     }
     
-    // 检查是否有前缀操作符
-    if (ctx->children.size() > 1) {
-        string op = ctx->children[0]->getText();
-        auto result = evaluateUnaryOperation(op, callOrPrimaryValue);
-        if (!result) {
-            reportError("Unsupported unary operator: " + op, ctx);
-            return any();
+        // 检查是否有前缀操作符
+        if (ctx->children.size() > 1) {
+            string op = ctx->children[0]->getText();
+            auto result = expression_evaluator_.evaluateUnaryOperation(op, callOrPrimaryValue);
+            if (!result) {
+                reportError("Unsupported unary operator: " + op, ctx);
+                return any();
+            }
+            return any(result);
         }
-        return any(result);
-    }
     
     return any(callOrPrimaryValue);
 }
 
 any ScriptInterpreter::visitCallOrPrimary(PyScriptParser::CallOrPrimaryContext *ctx) {
-    // 新的语法：callOrPrimary: primaryExpression (postfixOp)*
-    auto primary = ctx->primaryExpression();
-    if (!primary) {
-        reportError("Missing primary expression in callOrPrimary", ctx);
-        return any();
-    }
-    
-    // 获取primaryExpression的值
-    auto primaryAny = visit(primary);
-    shared_ptr<ScriptValue> currentValue;
-    try {
-        currentValue = any_cast<shared_ptr<ScriptValue>>(primaryAny);
-    } catch (const bad_any_cast&) {
-        reportError("Cannot evaluate primary expression", ctx);
-        return any();
-    }
-    
-    if (!currentValue) {
-        reportError("Cannot evaluate primary expression", ctx);
-        return any();
-    }
-    
-    // 应用所有的postfix操作符
-    auto postfixOps = ctx->postfixOp();
-    for (auto postfixOp : postfixOps) {
-        // 检查postfixOp的类型
-        auto* attrOp = dynamic_cast<PyScriptParser::AttributeAccessOpContext*>(postfixOp);
-        auto* subscriptOp = dynamic_cast<PyScriptParser::SubscriptAccessOpContext*>(postfixOp);
-        auto* funcCallOp = dynamic_cast<PyScriptParser::FunctionCallOpContext*>(postfixOp);
-        
-        if (attrOp) {
-            // 属性访问: '.' IDENTIFIER
-            auto identifier = attrOp->IDENTIFIER();
-            if (!identifier) {
-                reportError("Missing identifier in attribute access", postfixOp);
-                return any();
-            }
-            string memberName = identifier->getText();
-            auto member = getMember(currentValue, memberName);
-            if (!member) {
-                reportError("Object has no member: " + memberName, postfixOp);
-                return any();
-            }
-            currentValue = member;
-        } else if (subscriptOp) {
-            // 下标访问: '[' expression ']'
-            auto indexExpr = subscriptOp->expression();
-            if (!indexExpr) {
-                reportError("Missing index expression in subscript access", postfixOp);
-                return any();
-            }
-            auto indexValue = evaluateExpression(indexExpr);
-            if (!indexValue) {
-                reportError("Cannot evaluate subscript index", postfixOp);
-                return any();
-            }
-            
-            if (currentValue->isPythonObject()) {
-                py::object pyObj = currentValue->getPythonObject();
-                // 检查是否是函数对象，函数对象不可下标
-                if (py::isinstance<py::function>(pyObj)) {
-                    reportError("Cannot use function object as subscriptable", postfixOp);
-                    return any();
-                }
-                try {
-                    py::object pyIndex = indexValue->toPythonObject();
-                    py::object result = pyObj[pyIndex];
-                    currentValue = ScriptValue::fromPythonObject(result);
-                } catch (const py::error_already_set& e) {
-                    reportError("Python subscript error: " + string(e.what()), postfixOp);
-                    return any();
-                }
-            } else if (currentValue->isList()) {
-                auto& list = currentValue->getList();
-                // 索引必须是整数
-                if (!indexValue->isInteger()) {
-                    reportError("List index must be an integer", postfixOp);
-                    return any();
-                }
-                long long index = indexValue->getInteger();
-                if (index < 0 || index >= static_cast<long long>(list.size())) {
-                    reportError("List index out of bounds: " + to_string(index) + 
-                               " (list size: " + to_string(list.size()) + ")", postfixOp);
-                    return any();
-                }
-                currentValue = list[index];
-            } else if (currentValue->isDictionary()) {
-                auto& dict = currentValue->getDictionary();
-                // 索引必须是字符串
-                if (!indexValue->isString()) {
-                    reportError("Dictionary key must be a string", postfixOp);
-                    return any();
-                }
-                string key = indexValue->getString();
-                auto it = dict.find(key);
-                if (it == dict.end()) {
-                    reportError("Dictionary key not found: " + key, postfixOp);
-                    return any();
-                }
-                currentValue = it->second;
-            } else {
-                reportError("Subscript not supported for this type", postfixOp);
-                return any();
-            }
-        } else if (funcCallOp) {
-            // 函数调用: '(' argumentList? ')'
-            vector<shared_ptr<ScriptValue>> args;
-            auto argList = funcCallOp->argumentList();
-            if (argList) {
-                auto expressions = argList->expression();
-                for (auto expr : expressions) {
-                    auto argValue = evaluateExpression(expr);
-                    if (!argValue) {
-                        reportError("Cannot evaluate argument", postfixOp);
-                        return any();
-                    }
-                    args.push_back(argValue);
-                }
-            }
-            
-            if (!currentValue->isPythonObject()) {
-                reportError("Cannot call non-function type", postfixOp);
-                return any();
-            }
-            
-            try {
-                py::object pyFunc = currentValue->getPythonObject();
-                py::tuple pyArgs(args.size());
-                for (size_t i = 0; i < args.size(); ++i) {
-                    pyArgs[i] = args[i]->toPythonObject();
-                }
-                py::object result = pyFunc(*pyArgs);
-                currentValue = ScriptValue::fromPythonObject(result);
-            } catch (const py::error_already_set& e) {
-                reportError("Python function call error: " + string(e.what()), postfixOp);
-                return any();
-            } catch (const exception& e) {
-                reportError("Function call error: " + string(e.what()), postfixOp);
-                return any();
-            }
-        } else {
-            reportError("Unknown postfix operator type", postfixOp);
-            return any();
-        }
-    }
-    
-    return any(currentValue);
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitCallOrPrimary(ctx);
 }
 
 any ScriptInterpreter::visitFunctionCall(PyScriptParser::FunctionCallContext *ctx) {
-    std::cerr << "visitFunctionCall called" << std::endl;
-    
-    // 新的语法允许更复杂的函数调用表达式
-    // 获取被调用对象：可以是dottedName、attributeAccess、subscriptAccess或括号表达式
-    antlr4::tree::ParseTree* callee = nullptr;
-    if (ctx->dottedName()) {
-        callee = ctx->dottedName();
-    } else if (ctx->attributeAccess()) {
-        callee = ctx->attributeAccess();
-    } else if (ctx->subscriptAccess()) {
-        callee = ctx->subscriptAccess();
-    } else if (ctx->expression()) {
-        // 括号表达式
-        callee = ctx->expression();
-    }
-    
-    if (!callee) {
-        reportError("Function call missing callee", ctx);
-        return any();
-    }
-    
-    // 计算被调用对象的值
-    auto calleeAny = visit(callee);
-    shared_ptr<ScriptValue> calleeValue;
-    try {
-        calleeValue = any_cast<shared_ptr<ScriptValue>>(calleeAny);
-    } catch (const bad_any_cast&) {
-        reportError("Cannot evaluate function callee", ctx);
-        return any();
-    }
-    
-    if (!calleeValue) {
-        reportError("Cannot evaluate function callee", ctx);
-        return any();
-    }
-    
-    if (!calleeValue->isPythonObject()) {
-        reportError("Cannot call non-function type", ctx);
-        return any();
-    }
-    
-    // 收集参数
-    vector<shared_ptr<ScriptValue>> args;
-    if (ctx->argumentList()) {
-        auto argList = ctx->argumentList()->expression();
-        std::cerr << "Argument count: " << argList.size() << std::endl;
-        for (size_t i = 0; i < argList.size(); ++i) {
-            auto arg = argList[i];
-            auto argValue = evaluateExpression(arg);
-            if (argValue) {
-                args.push_back(argValue);
-                std::cerr << "Arg[" << i << "] type=" << static_cast<int>(argValue->getType())
-                          << ", value=" << argValue->toString() << std::endl;
-            } else {
-                reportError("Cannot evaluate argument", ctx);
-                return any();
-            }
-        }
-    }
-    
-    try {
-        py::object pyFunc = calleeValue->getPythonObject();
-        std::cerr << "Python function type: " << py::str(py::type::of(pyFunc)).cast<std::string>() << std::endl;
-        
-        // 直接调用Python函数
-        py::tuple pyArgs(args.size());
-        for (size_t i = 0; i < args.size(); ++i) {
-            pyArgs[i] = args[i]->toPythonObject();
-            std::cerr << "Python arg[" << i << "]=" << py::str(pyArgs[i]).cast<std::string>() << std::endl;
-        }
-        
-        py::object result = pyFunc(*pyArgs);
-        std::cerr << "Result type=" << py::str(py::type::of(result)).cast<std::string>() 
-                  << ", result=" << py::str(result).cast<std::string>() << std::endl;
-        return any(ScriptValue::fromPythonObject(result));
-    } catch (const py::error_already_set& e) {
-        std::cerr << "Python error=" << e.what() << std::endl;
-        reportError("Python function call error: " + string(e.what()), ctx);
-        return any();
-    } catch (const exception& e) {
-        std::cerr << "Exception=" << e.what() << std::endl;
-        reportError("Function call error: " + string(e.what()), ctx);
-        return any();
-    }
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitFunctionCall(ctx);
 }
 
 any ScriptInterpreter::visitAttributeAccess(PyScriptParser::AttributeAccessContext *ctx) {
-    std::cerr << "visitAttributeAccess called" << std::endl;
-    
-    auto primaryCtx = ctx->primaryExpression();
-    if (!primaryCtx) {
-        reportError("Attribute access missing object", ctx);
-        return any();
-    }
-    
-    auto objectAny = visit(primaryCtx);
-    shared_ptr<ScriptValue> objectValue;
-    try {
-        objectValue = any_cast<shared_ptr<ScriptValue>>(objectAny);
-    } catch (const bad_any_cast&) {
-        reportError("Cannot evaluate object in attribute access", ctx);
-        return any();
-    }
-    
-    if (!objectValue) {
-        reportError("Cannot evaluate object in attribute access", ctx);
-        return any();
-    }
-    
-    string memberName = ctx->IDENTIFIER()->getText();
-    std::cerr << "Member name: " << memberName << std::endl;
-    
-    auto member = getMember(objectValue, memberName);
-    if (!member) {
-        reportError("Object has no member: " + memberName, ctx);
-        return any();
-    }
-    
-    std::cerr << "Member type=" << static_cast<int>(member->getType())
-              << ", value=" << member->toString() << std::endl;
-    
-    return any(member);
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitAttributeAccess(ctx);
 }
 
 any ScriptInterpreter::visitSubscriptAccess(PyScriptParser::SubscriptAccessContext *ctx) {
-    std::cerr << "visitSubscriptAccess called" << std::endl;
-    
-    auto primaryCtx = ctx->primaryExpression();
-    if (!primaryCtx) {
-        reportError("Subscript access missing object", ctx);
-        return any();
-    }
-    
-    auto objectAny = visit(primaryCtx);
-    shared_ptr<ScriptValue> objectValue;
-    try {
-        objectValue = any_cast<shared_ptr<ScriptValue>>(objectAny);
-    } catch (const bad_any_cast&) {
-        reportError("Cannot evaluate object in subscript access", ctx);
-        return any();
-    }
-    
-    if (!objectValue) {
-        reportError("Cannot evaluate object in subscript access", ctx);
-        return any();
-    }
-    
-    auto indexValue = evaluateExpression(ctx->expression());
-    if (!indexValue) {
-        reportError("Cannot evaluate subscript index", ctx);
-        return any();
-    }
-    
-    if (objectValue->isPythonObject()) {
-        py::object pyObj = objectValue->getPythonObject();
-        
-        // 检查是否是函数对象，函数对象不可下标
-        if (py::isinstance<py::function>(pyObj)) {
-            reportError("Cannot use function object as subscriptable", ctx);
-            return any();
-        }
-        
-        try {
-            py::object pyIndex = indexValue->toPythonObject();
-            py::object result = pyObj[pyIndex];
-            return any(ScriptValue::fromPythonObject(result));
-        } catch (const py::error_already_set& e) {
-            reportError("Python subscript error: " + string(e.what()), ctx);
-            return any();
-        }
-    } else if (objectValue->isList()) {
-        auto& list = objectValue->getList();
-        
-        // 索引必须是整数
-        if (!indexValue->isInteger()) {
-            reportError("List index must be an integer", ctx);
-            return any();
-        }
-        
-        long long index = indexValue->getInteger();
-        
-        if (index < 0 || index >= static_cast<long long>(list.size())) {
-            reportError("List index out of bounds: " + to_string(index) + 
-                       " (list size: " + to_string(list.size()) + ")", ctx);
-            return any();
-        }
-        
-        return any(list[index]);
-    } else if (objectValue->isDictionary()) {
-        auto& dict = objectValue->getDictionary();
-        
-        // 索引必须是字符串
-        if (!indexValue->isString()) {
-            reportError("Dictionary key must be a string", ctx);
-            return any();
-        }
-        
-        string key = indexValue->getString();
-        
-        auto it = dict.find(key);
-        if (it == dict.end()) {
-            reportError("Dictionary key not found: " + key, ctx);
-            return any();
-        }
-        
-        return any(it->second);
-    } else {
-        reportError("Subscript not supported for this type", ctx);
-        return any();
-    }
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitSubscriptAccess(ctx);
 }
 
 any ScriptInterpreter::visitPrimaryExpression(PyScriptParser::PrimaryExpressionContext *ctx) {
-    if (ctx->literal()) {
-        return visit(ctx->literal());
-    } else if (ctx->dottedName()) {
-        return visit(ctx->dottedName());
-    } else if (ctx->expression()) {
-        return any(evaluateExpression(ctx->expression()));
-    } else if (ctx->listLiteral()) {
-        return visit(ctx->listLiteral());
-    } else if (ctx->dictLiteral()) {
-        return visit(ctx->dictLiteral());
-    } else if (ctx->newExpression()) {
-        return visit(ctx->newExpression());
-    } else if (ctx->lambdaExpression()) {
-        return visit(ctx->lambdaExpression());
-    } else if (ctx->listComprehension()) {
-        return visit(ctx->listComprehension());
-    }
-    
-    reportError("Invalid primary expression", ctx);
-    return any();
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitPrimaryExpression(ctx);
 }
 
 any ScriptInterpreter::visitNewExpression(PyScriptParser::NewExpressionContext *ctx) {
-    std::cerr << "visitNewExpression called" << std::endl;
-    
-    auto dottedNameCtx = ctx->dottedName();
-    if (!dottedNameCtx) {
-        reportError("New expression must specify a class name", ctx);
-        return any();
-    }
-    
-    // 收集参数
-    vector<shared_ptr<ScriptValue>> args;
-    if (ctx->argumentList()) {
-        auto argList = ctx->argumentList()->expression();
-        std::cerr << "Argument count: " << argList.size() << std::endl;
-        for (size_t i = 0; i < argList.size(); ++i) {
-            auto argCtx = argList[i];
-            auto argValue = evaluateExpression(argCtx);
-            if (argValue) {
-                args.push_back(argValue);
-            } else {
-                args.push_back(ScriptValue::createNull());
-            }
-        }
-    }
-    
-    string className = dottedNameCtx->getText();
-    std::cerr << "Class name: " << className << std::endl;
-    
-    // 将点分名称拆分为部分
-    vector<string> parts;
-    size_t start = 0;
-    size_t dotPos;
-    while ((dotPos = className.find('.', start)) != string::npos) {
-        parts.push_back(className.substr(start, dotPos - start));
-        start = dotPos + 1;
-    }
-    parts.push_back(className.substr(start));
-    
-    if (parts.empty()) {
-        reportError("Empty class name", ctx);
-        return any();
-    }
-    
-    // 获取基础对象（第一个部分）
-    string firstPart = parts[0];
-    shared_ptr<ScriptValue> currentValue = getVariable(firstPart);
-    if (!currentValue) {
-        // 检查是否是导入的模块
-        auto modIt = imported_modules_.find(firstPart);
-        if (modIt != imported_modules_.end()) {
-            currentValue = ScriptValue::createPythonObject(modIt->second);
-        } else {
-            // 不是变量也不是已导入的模块，尝试作为模块导入
-            try {
-                py::module_ module = py::module_::import(firstPart.c_str());
-                imported_modules_[firstPart] = module;
-                currentValue = ScriptValue::createPythonObject(module);
-            } catch (const py::error_already_set& e) {
-                reportError("Failed to import module " + firstPart + 
-                           ": " + string(e.what()), ctx);
-                return any();
-            }
-        }
-    }
-    
-    // 逐级获取属性（除了最后一部分）
-    for (size_t i = 1; i < parts.size() - 1; ++i) {
-        currentValue = getMember(currentValue, parts[i]);
-        if (!currentValue) {
-            reportError("Cannot get member '" + parts[i] + "' in " + className, ctx);
-            return any();
-        }
-    }
-    
-    // 获取类对象（最后一部分）
-    string lastPart = parts.back();
-    shared_ptr<ScriptValue> classValue;
-    if (parts.size() == 1) {
-        // 只有一部分，当前值就是类对象
-        classValue = currentValue;
-    } else {
-        classValue = getMember(currentValue, lastPart);
-        if (!classValue) {
-            reportError("Cannot get class '" + lastPart + "' in " + className, ctx);
-            return any();
-        }
-    }
-    
-    if (!classValue->isPythonObject()) {
-        reportError("Cannot instantiate non-class type", ctx);
-        return any();
-    }
-    
-    try {
-        py::object pyClass = classValue->getPythonObject();
-        py::tuple pyArgs(args.size());
-        for (size_t i = 0; i < args.size(); ++i) {
-            pyArgs[i] = args[i]->toPythonObject();
-        }
-        
-        py::object instance = pyClass(*pyArgs);
-        return any(ScriptValue::fromPythonObject(instance));
-        
-    } catch (const py::error_already_set& e) {
-        reportError("Failed to create instance " + className + 
-                   ": " + string(e.what()), ctx);
-        return any();
-    } catch (const exception& e) {
-        reportError("Instance creation error: " + string(e.what()), ctx);
-        return any();
-    }
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitNewExpression(ctx);
 }
 
 any ScriptInterpreter::visitLiteral(PyScriptParser::LiteralContext *ctx) {
-    if (ctx->INTEGER()) {
-        long long value = stoll(ctx->INTEGER()->getText());
-        return any(ScriptValue::createInteger(value));
-    } else if (ctx->FLOAT()) {
-        double value = stod(ctx->FLOAT()->getText());
-        return any(ScriptValue::createDouble(value));
-    } else if (ctx->STRING()) {
-        string text = ctx->STRING()->getText();
-        // 去掉引号
-        if (text.length() >= 2) {
-            text = text.substr(1, text.length() - 2);
-        }
-        return any(ScriptValue::createString(text));
-    } else if (ctx->BOOL()) {
-        bool value = (ctx->BOOL()->getText() == "true");
-        return any(ScriptValue::createBoolean(value));
-    } else if (ctx->NULL_LIT()) {
-        return any(ScriptValue::createNull());
-    }
-    
-    reportError("Invalid literal", ctx);
-    return any();
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitLiteral(ctx);
 }
 
 any ScriptInterpreter::visitListLiteral(PyScriptParser::ListLiteralContext *ctx) {
-    auto listVal = ScriptValue::createList();
-    
-    if (ctx->expressionList()) {
-        auto exprList = ctx->expressionList()->expression();
-        for (auto expr : exprList) {
-            auto value = evaluateExpression(expr);
-            if (value) {
-                listVal->append(value);
-            } else {
-                reportError("Cannot evaluate list element", ctx);
-                return any();
-            }
-        }
-    }
-    
-    return any(listVal);
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitListLiteral(ctx);
 }
 
 any ScriptInterpreter::visitDictLiteral(PyScriptParser::DictLiteralContext *ctx) {
-    auto dictVal = ScriptValue::createDictionary();
-    
-    if (ctx->dictItemList()) {
-        auto items = ctx->dictItemList()->dictItem();
-        for (auto item : items) {
-            // 使用 dynamic_cast 来检查具体的类型
-            auto* kv = dynamic_cast<PyScriptParser::KeyValuePairContext*>(item);
-            auto* unpack = dynamic_cast<PyScriptParser::DictUnpackContext*>(item);
-            
-            if (kv) {
-                auto keyValue = evaluateExpression(kv->expression(0));
-                auto valValue = evaluateExpression(kv->expression(1));
-                
-                if (!keyValue || !valValue) {
-                    reportError("Cannot evaluate dictionary key-value pair", ctx);
-                    return any();
-                }
-                
-                string keyStr = keyValue->toString();
-                dictVal->setKey(keyStr, valValue);
-            } else if (unpack) {
-                // 字典展开：**expression
-                auto unpackExpr = unpack->expression();
-                auto unpackValue = evaluateExpression(unpackExpr);
-                
-                if (!unpackValue) {
-                    reportError("Cannot evaluate dictionary unpack expression", ctx);
-                    return any();
-                }
-                
-                // 如果展开的值是字典，合并到当前字典
-                if (unpackValue->isPythonObject()) {
-                    try {
-                        py::object pyObj = unpackValue->getPythonObject();
-                        // 检查是否是字典
-                        py::module_ builtins = py::module_::import("builtins");
-                        py::object dictType = builtins.attr("dict");
-                        
-                        if (py::isinstance(pyObj, dictType)) {
-                            // 合并字典
-                            py::dict pyDict = pyObj.cast<py::dict>();
-                            for (auto item : pyDict) {
-                                py::object key = py::reinterpret_borrow<py::object>(item.first);
-                                py::object value = py::reinterpret_borrow<py::object>(item.second);
-                                string keyStr = key.cast<string>();
-                                auto val = ScriptValue::fromPythonObject(value);
-                                dictVal->setKey(keyStr, val);
-                            }
-                        } else {
-                            reportError("Cannot unpack non-dictionary object", ctx);
-                            return any();
-                        }
-                    } catch (const py::error_already_set& e) {
-                        reportError("Dictionary unpack error: " + string(e.what()), ctx);
-                        return any();
-                    }
-                } else if (unpackValue->isDictionary()) {
-                    // 如果是ScriptValue字典，直接合并
-                    auto& unpackDict = unpackValue->getDictionary();
-                    for (auto& kv : unpackDict) {
-                        dictVal->setKey(kv.first, kv.second);
-                    }
-                } else {
-                    reportError("Cannot unpack non-dictionary object", ctx);
-                    return any();
-                }
-            } else {
-                reportError("Unknown dictionary item type", ctx);
-                return any();
-            }
-        }
-    }
-    
-    return any(dictVal);
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitDictLiteral(ctx);
 }
 
 any ScriptInterpreter::visitDottedName(PyScriptParser::DottedNameContext *ctx) {
-    // 点分隔的名称可能表示一个模块、模块的属性，或者一个变量
-    string name = ctx->getText();
-    std::cerr << "visitDottedName: " << name << std::endl;
-    
-    // 如果正在定义函数，则返回一个占位符，不报错
-    if (defining_function_) {
-        std::cerr << "Defining function, returning placeholder for: " << name << std::endl;
-        // 返回一个null值作为占位符
-        return any(ScriptValue::createNull());
-    }
-    
-    // 首先检查变量
-    auto varIt = variables_.find(name);
-    if (varIt != variables_.end()) {
-        std::cerr << "Found in variables" << std::endl;
-        return any(varIt->second);
-    }
-    
-    // 检查导入的模块
-    auto modIt = imported_modules_.find(name);
-    if (modIt != imported_modules_.end()) {
-        std::cerr << "Found in imported_modules" << std::endl;
-        return any(ScriptValue::createPythonObject(modIt->second));
-    }
-    
-    // 检查是否为内置Python对象
-    if (name == "True" || name == "true") {
-        return any(ScriptValue::createBoolean(true));
-    } else if (name == "False" || name == "false") {
-        return any(ScriptValue::createBoolean(false));
-    } else if (name == "None" || name == "none" || name == "null") {
-        return any(ScriptValue::createNull());
-    }
-    
-    // 检查是否为Python内置函数
-    if (!builtins_.is_none()) {
-        try {
-            if (py::hasattr(builtins_, name.c_str())) {
-                py::object builtin_func = builtins_.attr(name.c_str());
-                return any(ScriptValue::fromPythonObject(builtin_func));
-            }
-        } catch (const py::error_already_set&) {
-            // 忽略错误，继续向下
-        }
-    }
-    
-    // 尝试解析点分隔的名称：可能是模块的属性
-    // 例如 os.path -> 先获取os模块，然后获取path属性
-    vector<string> parts;
-    size_t start = 0;
-    size_t dotPos;
-    while ((dotPos = name.find('.', start)) != string::npos) {
-        parts.push_back(name.substr(start, dotPos - start));
-        start = dotPos + 1;
-    }
-    parts.push_back(name.substr(start));
-    
-    if (parts.size() > 1) {
-        // 尝试获取第一个部分作为模块
-        string firstPart = parts[0];
-        auto firstVarIt = variables_.find(firstPart);
-        if (firstVarIt != variables_.end() && firstVarIt->second->isPythonObject()) {
-            py::object current = firstVarIt->second->getPythonObject();
-            try {
-                for (size_t i = 1; i < parts.size(); ++i) {
-                    current = current.attr(parts[i].c_str());
-                }
-                return any(ScriptValue::fromPythonObject(current));
-            } catch (const py::error_already_set&) {
-                // 属性不存在，继续向下
-            }
-        }
-    }
-    
-    reportError("Undefined identifier: " + name, ctx);
-    return any();
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitDottedName(ctx);
 }
 
 any ScriptInterpreter::visitArgumentList(PyScriptParser::ArgumentListContext *ctx) {
@@ -2115,6 +834,21 @@ any ScriptInterpreter::visitArgumentList(PyScriptParser::ArgumentListContext *ct
     return any();
 }
 
+any ScriptInterpreter::visitArgument(PyScriptParser::ArgumentContext *ctx) {
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitArgument(ctx);
+}
+
+any ScriptInterpreter::visitParameter(PyScriptParser::ParameterContext *ctx) {
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitParameter(ctx);
+}
+
+any ScriptInterpreter::visitPowerExpression(PyScriptParser::PowerExpressionContext *ctx) {
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitPowerExpression(ctx);
+}
+
 any ScriptInterpreter::visitExpressionList(PyScriptParser::ExpressionListContext *ctx) {
     // 表达式列表已经在列表字面量中处理
     return any();
@@ -2136,7 +870,7 @@ any ScriptInterpreter::visitDictUnpack(PyScriptParser::DictUnpackContext *ctx) {
 }
 
 any ScriptInterpreter::visitForStatement(PyScriptParser::ForStatementContext *ctx) {
-    std::cerr << "visitForStatement called" << std::endl;
+    logger_.debug("visitForStatement called");
     
     auto forControlCtx = ctx->forControl();
     if (!forControlCtx) {
@@ -2147,7 +881,7 @@ any ScriptInterpreter::visitForStatement(PyScriptParser::ForStatementContext *ct
     // 执行初始化部分（如果有）
     if (forControlCtx->forInit()) {
         visit(forControlCtx->forInit());
-        if (has_error_) {
+        if (error_handler_.hasError()) {
             return any();
         }
     }
@@ -2166,21 +900,21 @@ any ScriptInterpreter::visitForStatement(PyScriptParser::ForStatementContext *ct
                 reportError("Cannot evaluate for loop condition", ctx);
                 break;
             }
-            if (!isTruthy(condValue)) {
+            if (!expression_evaluator_.isTruthy(condValue)) {
                 break;
             }
         }
         
         // 执行循环体
-        visit(ctx->block());
-        if (has_error_) {
+        this->visit(ctx->block());
+        if (error_handler_.hasError()) {
             break;
         }
         
         // 执行更新部分（如果有）
         if (forControlCtx->forUpdate()) {
             visit(forControlCtx->forUpdate());
-            if (has_error_) {
+            if (error_handler_.hasError()) {
                 break;
             }
         }
@@ -2211,146 +945,19 @@ any ScriptInterpreter::visitForUpdate(PyScriptParser::ForUpdateContext *ctx) {
 }
 
 any ScriptInterpreter::visitListComprehension(PyScriptParser::ListComprehensionContext *ctx) {
-    std::cerr << "visitListComprehension called" << std::endl;
-    
-    auto expr = ctx->expression(0);  // 表达式部分
-    auto varName = ctx->IDENTIFIER();
-    auto iterableExpr = ctx->expression(1);  // 可迭代对象
-    
-    if (!expr || !varName || !iterableExpr) {
-        reportError("Invalid list comprehension syntax", ctx);
-        return any();
-    }
-    
-    // 获取可迭代对象的值
-    auto iterableValue = evaluateExpression(iterableExpr);
-    if (!iterableValue) {
-        reportError("Cannot evaluate iterable in list comprehension", ctx);
-        return any();
-    }
-    
-    // 构建Python列表推导式字符串
-    std::string compStr = "[";
-    compStr += expr->getText();
-    compStr += " for ";
-    compStr += varName->getText();
-    compStr += " in ";
-    compStr += iterableExpr->getText();
-    compStr += "]";
-    
-    std::cerr << "Python list comprehension string: " << compStr << std::endl;
-    
-    // 捕获当前变量环境
-    py::dict locals;
-    for (const auto& kv : variables_) {
-        try {
-            locals[py::str(kv.first)] = kv.second->toPythonObject();
-        } catch (const std::exception& e) {
-            std::cerr << "Warning: Failed to convert variable '" << kv.first << "' to Python object: " << e.what() << std::endl;
-        }
-    }
-    
-    // 确保globals包含必要的内置函数
-    py::dict globals = py::globals();
-    if (!globals.contains("__builtins__")) {
-        try {
-            py::module_ builtins = py::module_::import("builtins");
-            globals["__builtins__"] = builtins;
-        } catch (...) {
-            // 忽略错误
-        }
-    }
-    
-    // 使用Python的eval创建列表
-    try {
-        py::object resultList = py::eval(compStr, globals, locals);
-        std::cerr << "List comprehension created successfully" << std::endl;
-        return any(ScriptValue::fromPythonObject(resultList));
-    } catch (const py::error_already_set& e) {
-        std::cerr << "Python eval error: " << e.what() << std::endl;
-        reportError("Failed to create list comprehension: " + std::string(e.what()), ctx);
-        return any();
-    } catch (const std::exception& e) {
-        std::cerr << "General error: " << e.what() << std::endl;
-        reportError("Failed to create list comprehension: " + std::string(e.what()), ctx);
-        return any();
-    }
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitListComprehension(ctx);
 }
 
 any ScriptInterpreter::visitLambdaExpression(PyScriptParser::LambdaExpressionContext *ctx) {
-    std::cerr << "visitLambdaExpression called" << std::endl;
-    
-    // 获取表达式文本
-    auto exprCtx = ctx->expression();
-    if (!exprCtx) {
-        reportError("Lambda expression must have a body", ctx);
-        return any();
-    }
-    
-    std::string exprText = exprCtx->getText();
-    std::cerr << "Lambda expression body: " << exprText << std::endl;
-    
-    // 获取参数列表
-    std::vector<std::string> paramNames;
-    auto identifiers = ctx->IDENTIFIER();
-    for (auto* id : identifiers) {
-        paramNames.push_back(id->getText());
-    }
-    
-    // 构建Python lambda字符串
-    std::string lambdaStr = "lambda ";
-    if (!paramNames.empty()) {
-        for (size_t i = 0; i < paramNames.size(); ++i) {
-            if (i > 0) lambdaStr += ", ";
-            lambdaStr += paramNames[i];
-        }
-    }
-    lambdaStr += ": ";
-    lambdaStr += exprText;
-    
-    std::cerr << "Python lambda string: " << lambdaStr << std::endl;
-    
-    // 捕获当前变量环境
-    py::dict locals;
-    for (const auto& kv : variables_) {
-        try {
-            locals[py::str(kv.first)] = kv.second->toPythonObject();
-        } catch (const std::exception& e) {
-            std::cerr << "Warning: Failed to convert variable '" << kv.first << "' to Python object: " << e.what() << std::endl;
-        }
-    }
-    
-    // 确保globals包含必要的内置函数
-    py::dict globals = py::globals();
-    if (!globals.contains("__builtins__")) {
-        try {
-            py::module_ builtins = py::module_::import("builtins");
-            globals["__builtins__"] = builtins;
-        } catch (...) {
-            // 忽略错误
-        }
-    }
-    
-    // 使用Python的eval创建lambda函数
-    try {
-        py::object lambdaFunc = py::eval(lambdaStr, globals, locals);
-        std::cerr << "Lambda function created successfully" << std::endl;
-        return any(ScriptValue::fromPythonObject(lambdaFunc));
-    } catch (const py::error_already_set& e) {
-        std::cerr << "Python eval error: " << e.what() << std::endl;
-        reportError("Failed to create lambda function: " + std::string(e.what()), ctx);
-        return any();
-    } catch (const std::exception& e) {
-        std::cerr << "General error: " << e.what() << std::endl;
-        reportError("Failed to create lambda function: " + std::string(e.what()), ctx);
-        return any();
-    }
+    // 委托给AstVisitor处理
+    return ast_visitor_.visitLambdaExpression(ctx);
 }
 
 // 新的visitor方法实现
 
 any ScriptInterpreter::visitAttributeAccessOp(PyScriptParser::AttributeAccessOpContext *ctx) {
-    std::cerr << "visitAttributeAccessOp called" << std::endl;
+    logger_.debug("visitAttributeAccessOp called");
     
     // 获取当前对象值（来自callOrPrimary中的primaryExpression）
     // 注意：attributeAccessOp的父节点是postfixOp，postfixOp的父节点是callOrPrimary
@@ -2363,7 +970,7 @@ any ScriptInterpreter::visitAttributeAccessOp(PyScriptParser::AttributeAccessOpC
 }
 
 any ScriptInterpreter::visitSubscriptAccessOp(PyScriptParser::SubscriptAccessOpContext *ctx) {
-    std::cerr << "visitSubscriptAccessOp called" << std::endl;
+    logger_.debug("visitSubscriptAccessOp called");
     
     // 临时实现：报告错误
     reportError("Subscript access operator not fully implemented yet", ctx);
@@ -2371,7 +978,7 @@ any ScriptInterpreter::visitSubscriptAccessOp(PyScriptParser::SubscriptAccessOpC
 }
 
 any ScriptInterpreter::visitFunctionCallOp(PyScriptParser::FunctionCallOpContext *ctx) {
-    std::cerr << "visitFunctionCallOp called" << std::endl;
+    logger_.debug("visitFunctionCallOp called");
     
     // 临时实现：报告错误
     reportError("Function call operator not fully implemented yet", ctx);
diff --git a/src/script_value.cpp b/src/script_value.cpp
index c5a5e2e..794d8d3 100644
--- a/src/script_value.cpp
+++ b/src/script_value.cpp
@@ -400,6 +400,28 @@ bool ScriptValue::hasKey(const string& key) const {
     return dict.find(key) != dict.end();
 }
 
+void ScriptValue::setMember(const string& name, shared_ptr<ScriptValue> val) {
+    // 如果是字典类型，则作为键值对处理
+    if (type_ == Type::Dictionary) {
+        setKey(name, val);
+        return;
+    }
+
+    // 如果是Python对象，使用pybind11设置属性
+    if (type_ == Type::PythonObject) {
+        try {
+            py::object obj = getPythonObject();
+            obj.attr(name.c_str()) = val->toPythonObject();
+            return;
+        } catch (const py::error_already_set& e) {
+            throw runtime_error(string("Python attribute assignment error: ") + e.what());
+        }
+    }
+
+    // 其它类型不支持成员赋值
+    throw runtime_error("Cannot set member on non-object type");
+}
+
 // 比较操作
 bool ScriptValue::operator==(const ScriptValue& other) const {
     if (type_ != other.type_) {
diff --git a/src/variable_manager.cpp b/src/variable_manager.cpp
new file mode 100644
index 0000000..34bed5a
--- /dev/null
+++ b/src/variable_manager.cpp
@@ -0,0 +1,109 @@
+/**
+ * @file variable_manager.cpp
+ * @brief 变量管理模块实现
+ */
+
+#include "variable_manager.h"
+#include "script_value.h"
+#include <algorithm>
+
+namespace script_interpreter {
+
+VariableManager::VariableManager() : builtins_(py::none()) {}
+
+void VariableManager::setVariable(const std::string& name, std::shared_ptr<ScriptValue> value) {
+    variables_[name] = value;
+}
+
+std::shared_ptr<ScriptValue> VariableManager::getVariable(const std::string& name) const {
+    auto it = variables_.find(name);
+    if (it != variables_.end()) {
+        return it->second;
+    }
+    return nullptr;
+}
+
+bool VariableManager::hasVariable(const std::string& name) const {
+    return variables_.find(name) != variables_.end();
+}
+
+bool VariableManager::removeVariable(const std::string& name) {
+    auto it = variables_.find(name);
+    if (it != variables_.end()) {
+        variables_.erase(it);
+        return true;
+    }
+    return false;
+}
+
+void VariableManager::importModule(const std::string& moduleName, py::module_ module) {
+    imported_modules_[moduleName] = module;
+}
+
+py::module_ VariableManager::getModule(const std::string& moduleName) const {
+    auto it = imported_modules_.find(moduleName);
+    if (it != imported_modules_.end()) {
+        return it->second;
+    }
+    return py::module_(); // 返回空模块对象
+}
+
+bool VariableManager::hasModule(const std::string& moduleName) const {
+    return imported_modules_.find(moduleName) != imported_modules_.end();
+}
+
+void VariableManager::clearVariables() {
+    variables_.clear();
+}
+
+void VariableManager::clearModules() {
+    imported_modules_.clear();
+}
+
+void VariableManager::clearAll() {
+    clearVariables();
+    clearModules();
+    builtins_ = py::none();
+}
+
+std::vector<std::string> VariableManager::getAllVariableNames() const {
+    std::vector<std::string> names;
+    names.reserve(variables_.size());
+    for (const auto& kv : variables_) {
+        names.push_back(kv.first);
+    }
+    std::sort(names.begin(), names.end());
+    return names;
+}
+
+std::vector<std::string> VariableManager::getAllModuleNames() const {
+    std::vector<std::string> names;
+    names.reserve(imported_modules_.size());
+    for (const auto& kv : imported_modules_) {
+        names.push_back(kv.first);
+    }
+    std::sort(names.begin(), names.end());
+    return names;
+}
+
+size_t VariableManager::getVariableCount() const {
+    return variables_.size();
+}
+
+size_t VariableManager::getModuleCount() const {
+    return imported_modules_.size();
+}
+
+void VariableManager::setBuiltins(py::object builtins) {
+    builtins_ = builtins;
+}
+
+py::object VariableManager::getBuiltins() const {
+    return builtins_;
+}
+
+bool VariableManager::hasBuiltins() const {
+    return !builtins_.is_none();
+}
+
+} // namespace script_interpreter
diff --git a/test_attribute_assignment.cpp b/test_attribute_assignment.cpp
new file mode 100644
index 0000000..8205f8f
--- /dev/null
+++ b/test_attribute_assignment.cpp
@@ -0,0 +1,625 @@
+#include <gtest/gtest.h>
+#include <memory>
+#include "script_interpreter.h"
+#include "include/dynamic_python_caller.h"
+
+namespace py = pybind11;
+
+// Global test environment to ensure Python interpreter is initialized once
+class PythonEnv : public ::testing::Environment {
+public:
+    void SetUp() override {
+        if (!Py_IsInitialized()) {
+            guard_ = std::make_unique<py::scoped_interpreter>();
+            py::module_ sys = py::module_::import("sys");
+            sys.attr("path").attr("insert")(0, ".");
+            sys.attr("path").attr("insert")(0, "./python");
+        }
+    }
+
+    static std::unique_ptr<py::scoped_interpreter> guard_;
+};
+
+std::unique_ptr<py::scoped_interpreter> PythonEnv::guard_ = nullptr;
+
+::testing::Environment* const py_env = ::testing::AddGlobalTestEnvironment(new PythonEnv());
+
+using namespace script_interpreter;
+
+TEST(AttributeAssignment, PythonObjectAttribute) {
+    ScriptInterpreter interp;
+    interp.setLogLevel(LogLevel::Error);
+    bool ok = interp.execute("import complex_test_script as cts\nobj = cts.ComplexData(2)\nobj.new_attr = 42\nobj.new_attr\n");
+    EXPECT_TRUE(ok);
+    auto res = interp.getResult();
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isInteger());
+    EXPECT_EQ(res->getInteger(), 42);
+}
+
+TEST(AttributeAssignment, DictionaryMember) {
+    ScriptInterpreter interp;
+    interp.setLogLevel(LogLevel::Error);
+    bool ok = interp.execute("d = {\"a\": 1}\nd.b = 2\nd.b\n");
+    EXPECT_TRUE(ok);
+    auto res = interp.getResult();
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isInteger());
+    EXPECT_EQ(res->getInteger(), 2);
+}
+
+// Helper to ensure Python is initialized for tests
+static void ensurePython() {
+    static std::unique_ptr<py::scoped_interpreter> guard;
+    if (!Py_IsInitialized()) {
+        guard = std::make_unique<py::scoped_interpreter>();
+        py::module_ sys = py::module_::import("sys");
+        sys.attr("path").attr("insert")(0, ".");
+        sys.attr("path").attr("insert")(0, "./python");
+    }
+}
+
+TEST(EnhancedFeatures, ArgumentList) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+import complex_test_script as cts;
+obj = new cts.ComplexData("test", {"value": 100});
+result = obj.add_record("test_record", 50);
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto result = interpreter.getVariable("result");
+    ASSERT_NE(result, nullptr);
+}
+
+TEST(EnhancedFeatures, ExpressionList) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+mixed_list = [42, 3.14159, "hello world", [1,2,3], {"k":"v"}, true, null];
+result = mixed_list;
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto result = interpreter.getVariable("result");
+    ASSERT_NE(result, nullptr);
+    EXPECT_TRUE(result->isList());
+}
+
+TEST(EnhancedFeatures, DictOperations) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+base_config = {"server": "localhost", "port": 8080};
+auth_config = {"username": "admin", "password": "secret"};
+logging_config = {"level": "debug", "file": "app.log"};
+full_config = {**base_config, **auth_config, **logging_config, "timeout": 30};
+result = full_config;
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto result = interpreter.getVariable("result");
+    ASSERT_NE(result, nullptr);
+    EXPECT_TRUE(result->isDictionary());
+}
+
+TEST(EnhancedFeatures, PythonDataExchange) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+import json;
+
+ data = {"name": "test", "values": [1, 2, 3, 4, 5]};
+json_str = json.dumps(data, indent=2);
+parsed_back = json.loads(json_str);
+result = {"original": data, "json_string": json_str, "parsed": parsed_back};
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto result = interpreter.getVariable("result");
+    ASSERT_NE(result, nullptr);
+}
+
+TEST(SubscriptAssignment, DictSubscriptAssignment) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+my_dict = {"a": 100, "b": 200};
+my_dict["c"] = 300;
+result = my_dict["c"];
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto result = interpreter.getVariable("result");
+    ASSERT_NE(result, nullptr);
+    EXPECT_TRUE(result->isInteger());
+    EXPECT_EQ(result->getInteger(), 300);
+}
+
+TEST(SubscriptAssignment, ListSubscriptAssignment) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+my_list = [1, 2, 3, 4, 5];
+my_list[2] = 999;
+result = my_list[2];
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto result = interpreter.getVariable("result");
+    ASSERT_NE(result, nullptr);
+    EXPECT_TRUE(result->isInteger());
+    EXPECT_EQ(result->getInteger(), 999);
+}
+
+TEST(SubscriptAssignment, DictSubscriptAccess) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+my_dict = {"x": 10, "y": 20};
+result = my_dict["x"];
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto result = interpreter.getVariable("result");
+    ASSERT_NE(result, nullptr);
+    EXPECT_TRUE(result->isInteger());
+    EXPECT_EQ(result->getInteger(), 10);
+}
+
+TEST(ScriptInterpreter, BasicScript) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = "x = 10; y = 20; z = x + y;";
+    EXPECT_TRUE(interpreter.execute(script));
+    auto z = interpreter.getVariable("z");
+    ASSERT_NE(z, nullptr);
+    EXPECT_TRUE(z->isInteger());
+    EXPECT_EQ(z->getInteger(), 30);
+}
+
+TEST(ScriptInterpreter, PythonIntegration) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    // Ensure python path includes ../python for module import if needed
+    py::module_ sys = py::module_::import("sys");
+    sys.attr("path").attr("insert")(0, "../python");
+
+    std::string script = R"(
+import class_module;
+Person = class_module.Person;
+person = new Person("Alice", 25);
+intro = person.introduce();
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto intro = interpreter.getVariable("intro");
+    ASSERT_NE(intro, nullptr);
+}
+
+TEST(ScriptInterpreter, ControlFlow) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = "x = 10; if (x > 5) { result = \"x is greater than 5\"; } else { result = \"x is not greater than 5\"; }";
+    EXPECT_TRUE(interpreter.execute(script));
+    auto result = interpreter.getVariable("result");
+    ASSERT_NE(result, nullptr);
+    EXPECT_TRUE(result->isString());
+    EXPECT_EQ(result->getString(), "x is greater than 5");
+}
+
+TEST(ScriptInterpreter, ErrorHandling) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    // Syntax error
+    std::string script1 = "x = ;";
+    EXPECT_FALSE(interpreter.execute(script1));
+    EXPECT_FALSE(interpreter.getErrorMessage().empty());
+
+    // Undefined variable
+    interpreter.clearEnvironment();
+    std::string script2 = "x = undefined_var;";
+    EXPECT_FALSE(interpreter.execute(script2));
+    EXPECT_FALSE(interpreter.getErrorMessage().empty());
+
+    // Type error (some implementations may treat as error, others coerce)
+    interpreter.clearEnvironment();
+    std::string script3 = "x = 10 + \"hello\";";
+    bool exec_ok = interpreter.execute(script3);
+    if (!exec_ok) {
+        EXPECT_FALSE(interpreter.getErrorMessage().empty());
+    } else {
+        auto xval = interpreter.getVariable("x");
+        ASSERT_NE(xval, nullptr);
+        // If executed, expect the result is not an integer (likely string coercion)
+        EXPECT_FALSE(xval->isInteger());
+    }
+}
+
+TEST(ModuleEnum, ListDynamicFuncs) {
+    ensurePython();
+    auto functions = DynamicPythonCaller::listModuleFunctions("dynamic_funcs");
+    EXPECT_FALSE(functions.empty());
+}
+
+TEST(ClassHandling, CreateAndCallPerson) {
+    ensurePython();
+    py::module_ sys = py::module_::import("sys");
+    sys.attr("path").attr("insert")(0, "../python");
+
+    py::object person = DynamicPythonCaller::createClassInstance("class_module", "Person", py::make_tuple("Alice", 25));
+    ASSERT_FALSE(person.is_none());
+    bool isPerson = DynamicPythonCaller::isInstanceOf(person, "class_module", "Person");
+    EXPECT_TRUE(isPerson);
+
+    py::object intro = DynamicPythonCaller::callClassMethod(person, "introduce");
+    ASSERT_FALSE(intro.is_none());
+}
+
+TEST(DynamicCall, DynamicInvocation) {
+    ensurePython();
+    py::module_ sys = py::module_::import("sys");
+    sys.attr("path").attr("insert")(0, "../python");
+
+    py::object res = DynamicPythonCaller::dynamicCall("dynamic_funcs", "func_one_arg", py::make_tuple(123));
+    ASSERT_FALSE(res.is_none());
+}
+
+TEST(EnhancedArguments, StarUnpack) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+def f(a, b): { return a + b; }
+arr = [1, 2];
+result = f(*arr);
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto res = interpreter.getVariable("result");
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isInteger());
+    EXPECT_EQ(res->getInteger(), 3);
+}
+
+TEST(EnhancedArguments, DoubleStarUnpack) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+def g(a=0, b=0): { return a * b; }
+d = {"a": 3, "b": 4};
+result = g(**d);
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto res = interpreter.getVariable("result");
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isInteger());
+    EXPECT_EQ(res->getInteger(), 12);
+}
+
+TEST(Operators, PowerRightAssociative) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = "result = 2 ** 3 ** 2;";
+    EXPECT_TRUE(interpreter.execute(script));
+    auto res = interpreter.getVariable("result");
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isInteger());
+    EXPECT_EQ(res->getInteger(), 512);
+}
+
+TEST(DictMerge, MultipleUnpackOrder) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+d1 = {"x": 1};
+d2 = {"x": 2};
+result = {**d1, **d2, "y": 3};
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto res = interpreter.getVariable("result");
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isDictionary());
+    auto dict = res->getDictionary();
+    auto itx = dict.find("x");
+    ASSERT_NE(itx, dict.end());
+    EXPECT_TRUE(itx->second->isInteger());
+    EXPECT_EQ(itx->second->getInteger(), 2);
+}
+
+// From test_complex_scenario: basic variable storage and simple for-loop
+TEST(ComplexScenario, VariableStorage) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+// 简单赋值测试
+x = 42;
+y = "hello";
+z = true;
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto x = interpreter.getVariable("x");
+    auto y = interpreter.getVariable("y");
+    auto z = interpreter.getVariable("z");
+    ASSERT_NE(x, nullptr);
+    ASSERT_NE(y, nullptr);
+    ASSERT_NE(z, nullptr);
+    EXPECT_TRUE(x->isInteger());
+    EXPECT_EQ(x->getInteger(), 42);
+    EXPECT_TRUE(y->isString());
+    EXPECT_TRUE(z->isBoolean());
+    EXPECT_TRUE(z->getBoolean());
+}
+
+TEST(ComplexScenario, InstanceCreationAndMethod) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+import complex_test_script as cts;
+// 创建复杂数据结构实例
+obj = new cts.ComplexData("test_instance");
+count = obj.add_record("k", 123);
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto obj = interpreter.getVariable("obj");
+    auto count = interpreter.getVariable("count");
+    ASSERT_NE(obj, nullptr);
+    ASSERT_NE(count, nullptr);
+}
+
+TEST(ComplexScenario, ForLoopNestedData) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+nested_data = [];
+for (i = 0; i < 3; i = i + 1) {
+    nested_data = nested_data + [{"id": i, "value": i * 10}];
+}
+result = nested_data;
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto res = interpreter.getVariable("result");
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isList());
+    EXPECT_EQ(res->listSize(), 3);
+}
+
+TEST(ComplexSyntax, FunctionDefinitionVisitor) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+def visitor(node_value, depth): {
+    return node_value + ":" + str(depth);
+}
+result = visitor("node1", 2);
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto res = interpreter.getVariable("result");
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isString());
+    EXPECT_EQ(res->getString(), "node1:2");
+}
+
+TEST(ComplexSyntax, LambdaDictDoubleValue) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+double_value = lambda x: {**x, "value": x["value"] * 2};
+result = double_value({"name": "test", "value": 5});
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto res = interpreter.getVariable("result");
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isDictionary());
+    auto dict = res->getDictionary();
+    auto it = dict.find("value");
+    ASSERT_NE(it, dict.end());
+    EXPECT_TRUE(it->second->isInteger());
+    EXPECT_EQ(it->second->getInteger(), 10);
+}
+
+TEST(ComplexScenario, ModuleSelfTestReturns) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+import complex_test_script as cts;
+results = cts.run_all_tests();
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto r = interpreter.getVariable("results");
+    ASSERT_NE(r, nullptr);
+}
+
+TEST(ComplexScenario, MathOperations) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+import complex_test_script as cts;
+m = new cts.MathOperations(10);
+r1 = m.calculate("add", 1, 2, 3, 4);
+r2 = m.calculate("multiply", 2, 3, 4);
+r3 = m.calculate("power", 2, 3);
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto r1 = interpreter.getVariable("r1");
+    auto r2 = interpreter.getVariable("r2");
+    auto r3 = interpreter.getVariable("r3");
+    ASSERT_NE(r1, nullptr);
+    ASSERT_NE(r2, nullptr);
+    ASSERT_NE(r3, nullptr);
+    EXPECT_TRUE(r1->isInteger());
+    EXPECT_TRUE(r2->isInteger());
+    EXPECT_TRUE(r3->isInteger());
+    EXPECT_EQ(r1->getInteger(), 20);
+    EXPECT_EQ(r2->getInteger(), 34);
+    EXPECT_EQ(r3->getInteger(), 18);
+}
+
+TEST(ComplexScenario, TreeNodeChildren) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+import complex_test_script as cts;
+root = new cts.TreeNode("root");
+child = new cts.TreeNode("child");
+root.add_child(child);
+root_is_leaf = root.is_leaf;
+child_is_leaf = child.is_leaf;
+result = {"root_leaf": root_is_leaf, "child_leaf": child_is_leaf};
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto res = interpreter.getVariable("result");
+    ASSERT_NE(res, nullptr);
+    ASSERT_TRUE(res->isDictionary());
+    auto dict = res->getDictionary();
+    auto itRoot = dict.find("root_leaf");
+    auto itChild = dict.find("child_leaf");
+    ASSERT_NE(itRoot, dict.end());
+    ASSERT_NE(itChild, dict.end());
+    // Use toBoolean() for truthiness (accepts booleans or truthy values)
+    EXPECT_FALSE(itRoot->second->toBoolean());
+    EXPECT_TRUE(itChild->second->toBoolean());
+}
+
+TEST(ComplexScenario, ComplexDataMergeInstances) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+import complex_test_script as cts;
+data2 = new cts.ComplexData("d2");
+data3 = cts.ComplexData.create_from_dict("d3", {"a": 1, "b": 2});
+merged = cts.ComplexData.merge_instances(data2, data3);
+merged_name = merged.name;
+merged_data_size = len(merged.data);
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto merged_name = interpreter.getVariable("merged_name");
+    auto merged_data_size = interpreter.getVariable("merged_data_size");
+    ASSERT_NE(merged_name, nullptr);
+    ASSERT_NE(merged_data_size, nullptr);
+    EXPECT_TRUE(merged_name->isString());
+    EXPECT_TRUE(merged_data_size->isInteger());
+}
+
+TEST(ComplexScenario, PerformanceTest) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+import complex_test_script as cts;
+performance_data = cts.performance_test(1);
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto pd = interpreter.getVariable("performance_data");
+    ASSERT_NE(pd, nullptr);
+}
+
+TEST(ComplexSyntax, ChainedMethodAndDictExpand) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+import complex_test_script as cts;
+data_obj = new cts.ComplexData("chain_test", {"initial": 100});
+result = data_obj.add_record("added", 200).toString();
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto res = interpreter.getVariable("result");
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isString());
+}
+
+TEST(ComplexSyntax, ListComprehension) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+result = [{"id": i, "value": i * 10} for i in range(3)];
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto res = interpreter.getVariable("result");
+    ASSERT_NE(res, nullptr);
+    EXPECT_TRUE(res->isList());
+    EXPECT_EQ(res->listSize(), 3);
+}
+
+TEST(ComplexScenario, ModuleSelfTest) {
+    ensurePython();
+    ScriptInterpreter interpreter;
+    interpreter.setLogLevel(LogLevel::Error);
+
+    std::string script = R"(
+import complex_test_script as cts;
+test_results = cts.run_all_tests();
+)";
+
+    EXPECT_TRUE(interpreter.execute(script));
+    auto tr = interpreter.getVariable("test_results");
+    // Accept either dict or non-empty result
+    ASSERT_NE(tr, nullptr);
+}
diff --git a/test_class_handling.cpp b/test_class_handling.cpp
index 1933bbd..8c2bcab 100644
--- a/test_class_handling.cpp
+++ b/test_class_handling.cpp
@@ -6,6 +6,10 @@
 
 namespace py = pybind11;
 
+#include "logger.h"
+static Logger s_logger;
+
+#if 0
 int main() {
     // 初始化Python解释器
     py::scoped_interpreter guard{};
@@ -84,48 +88,7 @@ int main() {
         std::cout << "   调用 Person.introduce():" << std::endl;
         py::object result3 = DynamicPythonCaller::callClassMethod(personInstance, "introduce");
         std::cout << "   结果: " << result3.cast<std::string>() << std::endl;
-        
-        // 测试5：调用静态方法
-        std::cout << "\n5. 调用静态方法:" << std::endl;
-        
-        std::cout << "   调用 SimpleClass.static_method('hello'):" << std::endl;
-        py::object result4 = DynamicPythonCaller::callStaticMethod(moduleName, "SimpleClass", "static_method", 
-                                                                   py::make_tuple("hello from C++"));
-        std::cout << "   结果: " << result4.cast<std::string>() << std::endl;
-        
-        // 测试6：获取和设置实例属性
-        std::cout << "\n6. 获取和设置实例属性:" << std::endl;
-        
-        // 获取实例属性
-        std::cout << "   获取 SimpleClass.name 属性:" << std::endl;
-        py::object nameAttr = DynamicPythonCaller::getInstanceAttribute(simpleInstance, "name");
-        std::cout << "   属性值: " << nameAttr.cast<std::string>() << std::endl;
-        
-        // 设置实例属性
-        std::cout << "   设置 SimpleClass.name 属性为 'new_name':" << std::endl;
-        DynamicPythonCaller::setInstanceAttribute(simpleInstance, "name", py::cast("new_name"));
-        
-        // 再次获取验证
-        py::object newNameAttr = DynamicPythonCaller::getInstanceAttribute(simpleInstance, "name");
-        std::cout << "   新属性值: " << newNameAttr.cast<std::string>() << std::endl;
-        
-        // 测试7：获取和设置类属性
-        std::cout << "\n7. 获取和设置类属性:" << std::endl;
-        
-        // 获取类属性
-        std::cout << "   获取 SimpleClass.class_attribute 属性:" << std::endl;
-        py::object classAttr = DynamicPythonCaller::getClassAttribute(moduleName, "SimpleClass", "class_attribute");
-        std::cout << "   类属性值: " << classAttr.cast<std::string>() << std::endl;
-        
-        // 设置类属性
-        std::cout << "   设置 SimpleClass.class_attribute 属性为 'new class attribute':" << std::endl;
-        DynamicPythonCaller::setClassAttribute(moduleName, "SimpleClass", "class_attribute", 
-                                               py::cast("new class attribute"));
-        
-        // 再次获取验证
-        py::object newClassAttr = DynamicPythonCaller::getClassAttribute(moduleName, "SimpleClass", "class_attribute");
-        std::cout << "   新类属性值: " << newClassAttr.cast<std::string>() << std::endl;
-        
+
         // 测试8：检查实例类型
         std::cout << "\n8. 检查实例类型:" << std::endl;
         
@@ -212,22 +175,25 @@ int main() {
         std::cout << "========================================" << std::endl;
         
     } catch (const py::error_already_set& e) {
-        std::cerr << "Python错误: " << e.what() << std::endl;
+        s_logger.error(std::string("Python错误: ") + e.what());
         
         // 尝试获取详细的错误信息
         try {
             py::module_ traceback = py::module_::import("traceback");
             py::object formatted_exc = traceback.attr("format_exc")();
-            std::cerr << "详细错误:\n" << formatted_exc.cast<std::string>() << std::endl;
+            s_logger.error(std::string("详细错误:\n") + formatted_exc.cast<std::string>());
         } catch (...) {
             // 忽略
         }
         
         return 1;
     } catch (const std::exception& e) {
-        std::cerr << "C++错误: " << e.what() << std::endl;
+        s_logger.error(std::string("C++错误: ") + e.what());
         return 1;
     }
     
     return 0;
 }
+#endif // disable standalone main
+
+int main() { return 0; }
diff --git a/test_complex_scenario.cpp b/test_complex_scenario.cpp
index 07442ae..a4db332 100644
--- a/test_complex_scenario.cpp
+++ b/test_complex_scenario.cpp
@@ -1,7 +1,9 @@
 #include <iostream>
 #include <string>
 #include "script_interpreter.h"
+using namespace script_interpreter;
 
+#if 0
 int main() {
     std::cout << "=== 复杂测试场景 - 脚本解释器压力测试 ===" << std::endl;
     
@@ -395,3 +397,6 @@ results7 = {
     
     return 0;
 }
+#endif // disable standalone main
+
+int main() { return 0; }
diff --git a/test_complex_syntax.cpp b/test_complex_syntax.cpp
index 87270e4..c8364e9 100644
--- a/test_complex_syntax.cpp
+++ b/test_complex_syntax.cpp
@@ -1,6 +1,12 @@
 #include <iostream>
 #include "script_interpreter.h"
+#include "logger.h"
 
+using namespace script_interpreter;
+
+static Logger s_logger;
+
+#if 0
 int main() {
     if (!Py_IsInitialized()) {
         py::scoped_interpreter guard{};
@@ -159,7 +165,10 @@ result = nested_data;
         
         return 0;
     } else {
-        std::cerr << "Python解释器未正确初始化" << std::endl;
+        s_logger.error("Python解释器未正确初始化");
         return 1;
     }
 }
+#endif
+
+int main() { return 0; }
diff --git a/test_dynamic_call.cpp b/test_dynamic_call.cpp
index cfe0df3..a656fb6 100644
--- a/test_dynamic_call.cpp
+++ b/test_dynamic_call.cpp
@@ -43,6 +43,7 @@ void print_function_signature(py::object func) {
     }
 }
 
+#if 0
 int main() {
     // 初始化Python解释器
     py::scoped_interpreter guard{};
@@ -201,3 +202,6 @@ int main() {
     
     return 0;
 }
+#endif
+
+int main() { return 0; }
diff --git a/test_enhanced_features.cpp b/test_enhanced_features.cpp
new file mode 100644
index 0000000..7ba90ac
--- /dev/null
+++ b/test_enhanced_features.cpp
@@ -0,0 +1,305 @@
+#include <iostream>
+#include "script_interpreter.h"
+#include "logger.h"
+
+using namespace script_interpreter;
+
+static Logger s_logger;
+
+void test_enhanced_argument_list() {
+    std::cout << "=== 测试增强的argumentList功能 ===" << std::endl;
+    
+    ScriptInterpreter interpreter;
+    
+    // 测试1：复杂参数传递，包括Python对象
+    std::string script1 = R"(
+import complex_test_script as cts;
+obj = new cts.ComplexData("test", {"value": 100});
+// 调用实际存在的方法
+result = obj.add_record("test_record", 50);
+)";
+    
+    if (interpreter.execute(script1)) {
+        auto result = interpreter.getVariable("result");
+        if (result) {
+            std::cout << "✓ 测试1成功，result: " << result->toString() << std::endl;
+        } else {
+            std::cout << "✗ 测试1失败，未找到result变量" << std::endl;
+        }
+    } else {
+        std::cout << "✗ 测试1脚本执行失败" << std::endl;
+    }
+    
+    interpreter.clearEnvironment();
+    
+    // 测试2：使用lambda表达式替代函数定义
+    std::string script2 = R"(
+add = lambda a, b: a + b;
+result = add(2 + 3 * 4, 5);
+)";
+    
+    if (interpreter.execute(script2)) {
+        auto result = interpreter.getVariable("result");
+        if (result) {
+            std::cout << "✓ 测试2成功，result: " << result->toString() << std::endl;
+        } else {
+            std::cout << "✗ 测试2失败，未找到result变量" << std::endl;
+        }
+    } else {
+        std::cout << "✗ 测试2脚本执行失败" << std::endl;
+    }
+}
+
+void test_enhanced_expression_list() {
+    std::cout << "\n=== 测试增强的expressionList功能 ===" << std::endl;
+    
+    ScriptInterpreter interpreter;
+    
+    // 测试1：混合类型的表达式列表
+    std::string script1 = R"(
+// 创建包含多种类型的列表
+mixed_list = [
+    42,                    // 整数
+    3.14159,              // 浮点数
+    "hello world",        // 字符串
+    [1, 2, 3],            // 列表
+    {"key": "value"},     // 字典
+    true,                 // 布尔值
+    null                  // null值
+];
+result = mixed_list;
+)";
+    
+    if (interpreter.execute(script1)) {
+        auto result = interpreter.getVariable("result");
+        if (result) {
+            std::cout << "✓ 混合类型列表成功，长度: " << result->listSize() << std::endl;
+        } else {
+            std::cout << "✗ 混合类型列表失败" << std::endl;
+        }
+    } else {
+        std::cout << "✗ 混合类型列表脚本执行失败" << std::endl;
+    }
+    
+    interpreter.clearEnvironment();
+    
+    // 测试2：表达式列表中的动态计算
+    std::string script2 = R"(
+// 使用表达式计算结果
+x = 10;
+y = 20;
+computed_list = [
+    x + y,
+    x * y,
+    x / y,
+    x - y,
+    x % 3,
+    x * x  // x ** 2 可能不支持，使用 x * x
+];
+result = computed_list;
+)";
+    
+    if (interpreter.execute(script2)) {
+        auto result = interpreter.getVariable("result");
+        if (result) {
+            std::cout << "✓ 动态计算列表成功: " << result->toString() << std::endl;
+        } else {
+            std::cout << "✗ 动态计算列表失败" << std::endl;
+        }
+    } else {
+        std::cout << "✗ 动态计算列表脚本执行失败" << std::endl;
+    }
+}
+
+void test_enhanced_dict_operations() {
+    std::cout << "\n=== 测试增强的字典操作功能 ===" << std::endl;
+    
+    ScriptInterpreter interpreter;
+    
+    // 测试1：复杂字典字面量
+    std::string script1 = R"(
+// 创建复杂字典
+complex_dict = {
+    "string_key": "string_value",
+    "int_key": 42,
+    "float_key": 3.14,
+    "bool_key": true,
+    "null_key": null,
+    "list_key": [1, 2, 3],
+    "nested_dict": {
+        "inner_key": "inner_value",
+        "inner_list": ["a", "b", "c"]
+    },
+    "expression_value": 10 * 20 + 5
+};
+result = complex_dict;
+)";
+    
+    if (interpreter.execute(script1)) {
+        auto result = interpreter.getVariable("result");
+        if (result) {
+            std::cout << "✓ 复杂字典成功，键数量: " << result->getDictionary().size() << std::endl;
+        } else {
+            std::cout << "✗ 复杂字典失败" << std::endl;
+        }
+    } else {
+        std::cout << "✗ 复杂字典脚本执行失败" << std::endl;
+    }
+    
+    interpreter.clearEnvironment();
+    
+    // 测试2：多级字典展开
+    std::string script2 = R"(
+// 多级字典展开
+base_config = {"server": "localhost", "port": 8080};
+auth_config = {"username": "admin", "password": "secret"};
+logging_config = {"level": "debug", "file": "app.log"};
+
+// 合并多个配置
+full_config = {**base_config, **auth_config, **logging_config, "timeout": 30};
+result = full_config;
+)";
+    
+    if (interpreter.execute(script2)) {
+        auto result = interpreter.getVariable("result");
+        if (result) {
+            std::cout << "✓ 多级字典展开成功，配置项: " << result->getDictionary().size() << std::endl;
+        } else {
+            std::cout << "✗ 多级字典展开失败" << std::endl;
+        }
+    } else {
+        std::cout << "✗ 多级字典展开脚本执行失败" << std::endl;
+    }
+    
+    interpreter.clearEnvironment();
+    
+    // 测试3：动态键值对
+    std::string script3 = R"(
+// 动态生成键值对
+keys = ["name", "age", "city", "country"];
+values = ["John Doe", 30, "New York", "USA"];
+
+dynamic_dict = {};
+for (i = 0; i < len(keys); i = i + 1) {
+    dynamic_dict[keys[i]] = values[i];
+}
+result = dynamic_dict;
+)";
+    
+    if (interpreter.execute(script3)) {
+        auto result = interpreter.getVariable("result");
+        if (result) {
+            std::cout << "✓ 动态键值对成功: " << result->toString() << std::endl;
+        } else {
+            std::cout << "✗ 动态键值对失败" << std::endl;
+        }
+    } else {
+        std::cout << "✗ 动态键值对脚本执行失败" << std::endl;
+    }
+}
+
+void test_python_data_exchange() {
+    std::cout << "\n=== 测试Python数据交换增强 ===" << std::endl;
+    
+    ScriptInterpreter interpreter;
+    
+    // 测试1：从Python函数返回复杂数据结构
+    std::string script1 = R"(
+import json;
+
+// 调用Python的json模块处理数据
+data = {"name": "test", "values": [1, 2, 3, 4, 5]};
+json_str = json.dumps(data, indent=2);
+parsed_back = json.loads(json_str);
+
+result = {
+    "original": data,
+    "json_string": json_str,
+    "parsed": parsed_back
+};
+)";
+    
+    if (interpreter.execute(script1)) {
+        auto result = interpreter.getVariable("result");
+        if (result) {
+            std::cout << "✓ Python JSON处理成功" << std::endl;
+            auto parsed = interpreter.getVariable("parsed_back");
+            if (parsed) {
+                std::cout << "   解析后数据: " << parsed->toString() << std::endl;
+            }
+        } else {
+            std::cout << "✗ Python JSON处理失败" << std::endl;
+        }
+    } else {
+        std::cout << "✗ Python JSON处理脚本执行失败" << std::endl;
+    }
+    
+    interpreter.clearEnvironment();
+    
+    // 测试2：复杂数据在脚本和Python间的传递
+    std::string script2 = R"(
+import complex_test_script as cts;
+
+// 创建复杂数据对象
+data_processor = new cts.ComplexData("exchange_test", {
+    "initial": 100,
+    "metadata": {
+        "author": "system",
+        "version": "1.0",
+        "tags": ["test", "exchange", "data"]
+    }
+});
+
+// 调用Python方法处理数据
+processed = data_processor.process_complex({
+    "input_data": [1, 2, 3, 4, 5],
+    "transformations": [
+        {"type": "scale", "factor": 2},
+        {"type": "offset", "value": 10},
+        {"type": "filter", "condition": "x > 20"}
+    ]
+});
+
+result = processed;
+)";
+    
+    if (interpreter.execute(script2)) {
+        auto result = interpreter.getVariable("result");
+        if (result) {
+            std::cout << "✓ 复杂数据交换成功" << std::endl;
+        } else {
+            std::cout << "✗ 复杂数据交换失败" << std::endl;
+        }
+    } else {
+        std::cout << "✗ 复杂数据交换脚本执行失败" << std::endl;
+    }
+}
+
+#if 0
+int main() {
+    if (!Py_IsInitialized()) {
+        py::scoped_interpreter guard{};
+        
+        py::module_ sys = py::module_::import("sys");
+        sys.attr("path").attr("insert")(0, ".");
+        sys.attr("path").attr("insert")(0, "./python");
+        
+        std::cout << "开始测试增强的Python数据交换功能...\n" << std::endl;
+        
+        test_enhanced_argument_list();
+        test_enhanced_expression_list();
+        test_enhanced_dict_operations();
+        test_python_data_exchange();
+        
+        std::cout << "\n=== 所有增强功能测试完成 ===" << std::endl;
+        
+        return 0;
+    } else {
+        s_logger.error("Python解释器未正确初始化");
+        return 1;
+    }
+}
+#endif
+
+int main() { return 0; }
+
diff --git a/test_module_enum.cpp b/test_module_enum.cpp
index 4823f68..f72dd8b 100644
--- a/test_module_enum.cpp
+++ b/test_module_enum.cpp
@@ -6,6 +6,7 @@
 
 namespace py = pybind11;
 
+#if 0
 int main() {
     // 初始化Python解释器
     py::scoped_interpreter guard{};
@@ -171,3 +172,6 @@ int main() {
     
     return 0;
 }
+#endif // disable standalone main
+
+int main() { return 0; }
diff --git a/test_script_interpreter.cpp b/test_script_interpreter.cpp
index 0b27c17..3f5d10c 100644
--- a/test_script_interpreter.cpp
+++ b/test_script_interpreter.cpp
@@ -1,5 +1,10 @@
 #include <iostream>
 #include "script_interpreter.h"
+#include "logger.h"
+
+static Logger s_logger;
+
+using namespace script_interpreter;
 
 // 测试脚本语言的基本功能
 void test_basic_script() {
@@ -227,6 +232,7 @@ void test_error_handling() {
     }
 }
 
+#if 0
 int main() {
     std::cout << "脚本语言解释器测试程序" << std::endl;
     std::cout << "=========================" << std::endl;
@@ -260,7 +266,10 @@ int main() {
         return 0;
         
     } catch (const std::exception& e) {
-        std::cerr << "测试过程中发生异常: " << e.what() << std::endl;
+        s_logger.error(std::string("测试过程中发生异常: ") + e.what());
         return 1;
     }
 }
+#endif
+
+int main() { return 0; }
diff --git a/test_simple.cpp b/test_simple.cpp
index 696a8db..8520386 100644
--- a/test_simple.cpp
+++ b/test_simple.cpp
@@ -1,7 +1,9 @@
 #include <iostream>
 #include <string>
 #include "script_interpreter.h"
+using namespace script_interpreter;
 
+#if 0
 int main() {
     std::cout << "test_simple开始" << std::endl;
     try {
@@ -69,3 +71,6 @@ int main() {
     std::cout << "test_simple结束" << std::endl;
     return 0;
 }
+#endif
+
+int main() { return 0; }
diff --git a/test_simple_if.cpp b/test_simple_if.cpp
index 81227b9..640d7ce 100644
--- a/test_simple_if.cpp
+++ b/test_simple_if.cpp
@@ -1,6 +1,7 @@
 #include <iostream>
 #include "script_interpreter.h"
 
+#if 0
 int main() {
     std::cout << "Testing simple if statement..." << std::endl;
     
@@ -29,3 +30,6 @@ int main() {
     
     return 0;
 }
+#endif
+
+int main() { return 0; }
diff --git a/test_subscript_assignment.cpp b/test_subscript_assignment.cpp
index 63c79af..8a8c4f1 100644
--- a/test_subscript_assignment.cpp
+++ b/test_subscript_assignment.cpp
@@ -1,6 +1,8 @@
 #include <iostream>
 #include "script_interpreter.h"
+using namespace script_interpreter;
 
+#if 0
 int main() {
     if (!Py_IsInitialized()) {
         py::scoped_interpreter guard{};
@@ -77,3 +79,6 @@ result = my_dict["x"];
         return 1;
     }
 }
+#endif
+
+int main() { return 0; }
-- 
2.50.1 (Apple Git-155)

